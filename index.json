{"project": "qiskit-terra", "project_url": "https://qiskit.org", "show_commit_url": "http://github.com/Qiskit/qiskit-terra/commit/", "hash_length": 8, "revision_to_hash": {"17": "50a6789997d89545c9efb63ce9de18335e6a7610", "451": "236f52e42fd30627feb77a4caf8fc8ccb4d67a5e", "867": "fdda48ab7c37eef994c27d43806d6773d440256e", "985": "d84c48a21e9fbf201ba3d0ea77153d7501f1fff0", "986": "9a621518ba04f31e6029d21f85edc0d16e830723", "1023": "e8f3f5f7c3b2aa2a6b434ced34e3f0ca84615842", "1099": "b049c4db914088d2c019358b8dc239a8995b006c", "1383": "22fc4f3cdb22e99150f61031e0341f52334edf52", "1405": "db0e78784ce4479e16a94ca016d19cb5b1d4208d", "1434": "8d534a40604c550ebe77a89012d16d047c9d760f", "1493": "35c373f5ce9bb18b2a5d4b9249da62d682661c12", "1548": "ebb02533599b04cbdafa0e4333ff31eed6928d50", "1611": "9294a3804c16f5a81fffbf5179ce7d9c9fdc3af1", "1703": "ec5102dc7649c594e4068a2b815b59d44ad8d48c", "1719": "7f881c9e883385c04f593da7a2f590046c5cde84", "1790": "9a576396aab4812b3b4d58220f53d5551beb1a59", "1793": "76d1e66347b383aab5a9a6fc6b26ef29d7f9b4fb", "1858": "8f8bcd52dacce670a61bc0103e157be1601a1ab4", "1860": "3e7c3fd075914a6d2896af61417a06c1aabfa3d5", "1865": "38c6e1d0c96ee45fd68cf59123fe876cb4c824d9", "1870": "4d95921a6489c075a25a5a4d6c3a691c32b3c1aa", "1887": "87a995b2d81a8e89387e897c6bdb475b9e17eb8a", "1892": "d8318b4fc099a3f5c30bb84a6d3f1e11dac263c3", "1899": "b281ee4b701d23e9aadd375593b23cd3ca6c57cd", "2936": "6e732d1dd8431cbbc8ce4abfe03ba7bd6f1d3277", "3058": "05291bb8a9ed2c24a276187be83543bbd17b6494", "3112": "fe507853fc07a2b2458f97308cd6dba8f23f0b0d", "3383": "b28fb3df0c5b8f0bb04200c6c38dd8bf84dd4308", "3471": "dc96b263ff6b4496656dae9c7b3e7f81d80de03b", "3514": "5ffa83a7ac73a8ab28ee831be187230271cb965c", "3807": "2e4cb3acaf1b88b016a5b61d96f2a99c5ba125a4", "3852": "95bba4c8d9d5c52b4c54ac2a1a579864d4965fe7", "3875": "d756dc196bec3e27ddb1c4c4f6e18d078ce2ebc5", "3902": "29e075f56cdf40fbaf3c42aa06e7bb8c6f768490", "3947": "df613ef8532115a85282f90679d7de9d45309bd0", "4030": "2dd47709b70fc9aeb6a8d878894d3f117448bd4f", "4278": "121980087264e5fbd740e203ab68dc1ef9d841dc", "4346": "badebbc96634f098c3207d0eb61e281a1af0d83a", "4400": "829ca256942495faedb705bda718d641da8e4c63", "5427": "a3c67a5505ba44dcf9bce2c03f9e5b8b3170f6db", "5454": "58f5ba91dd9ad9691a0912c2dea282a149a0d530", "7808": "bb5880d6275558e07929f163ad811fe8bc0f351e", "9293": "d5791fa62f246b5f91219f0ba75e67c2a6555215", "11737": "13bd519ffffe640f1337c66d65aeb9f494ea0938", "11904": "e99bce1a25f9e46a1d180a60b043938f0f3604c9", "12826": "c43f7d7bfdd75ceb302c3f24a220c0b5ad77ab73", "13364": "e9c579f4c362c98892cbe6d97a7247fc99158588", "15525": "111d774b041a1a1e415e26b6c0291f71403ca3b5", "16679": "30540d6693c8e581d2f46a0cd9fcdea72b01fc7e", "16795": "d9be39eed72316555a16921e13c193b0189025de", "18605": "7bf8b620c65cc8c0baa87a25dddce2ef7042455f", "19119": "3cf63baa3582d6cd5bcbeb976659dde3236f9007", "19887": "492b7e545b78e796ce42f601f6812d9a5a575606", "19889": "acb62a48755c34420d71e5680cdc237e2bd3d68b", "19896": "778abf3af652422b2fd7f4de8f020517aa693f56", "19898": "5f21ff39c1643adf6f837464e6fea484e60a46da", "19913": "03083dcc23c13fce17c66369c555943299547aeb", "19930": "ed8f8f84f6e1a264c435cc0f97e50387c2211cb7", "19968": "a8e98668432f0c823e57a1a1b07a6c559547b33e", "19989": "32e75838742799ddaae88171bdf7c06fe3ba2888", "19998": "a4b1b75ab0f0238cbaa8820ca7e4e363245664fa", "20005": "58771d82badb4a60da23132615086eaae3c038b5", "20011": "25160cd9a185f1a6dc650f9135b678f165e01be6", "20012": "775b15e8e1339ddc40f71e02314f9971360f167a", "20017": "31738f87e49acbe9df9a836979733acf8a7b4e8d", "20051": "ee8974d2eea65257ec8bd5044870a8ba440d1e74", "20064": "4dd47cf430e88b4b970f25d11696571f954fd653", "20073": "d04d8b076d909e17ea7b25862998475e6f26c100", "20086": "27df87038ea045b686e9c0ecaaddc0f99b62d561", "20091": "efaa29c6e3f0d8f07bdd62a793167848d7424ba6", "20095": "bcf97afdd3272c80db7e7d57747cd4c0ee928f79", "20098": "8657a2a6bbd4138728ac386d20384713d508ba9d", "20105": "7b6b05a300cbd2a53242e6f6b99f6f18d4aecdcd", "20128": "0cae45e5ebfa60cf99ba82dafa88c809c11414de", "20154": "186f4a8c2811234428442a9ab9a62679bfae0ac3", "20165": "9c3e6c6151b9d7c3e5635082b5e704876b8a6cc5", "20170": "719aafd62cc935042867858071bfa41bbc470940", "20185": "5da47fa221079a2324dd64dd8181f6e31acdacc9", "20191": "2f28f7e6c946de2208246a0caba5951775bfdd7e", "20196": "2c6693db0bfcd8807a42fa58b4e782aa4ceb335c", "20199": "ce6b231a78ae233f0e41f93f59ba4ee773560fab", "20251": "19d149a4d55f66295ba76cedc511db20510c35f8", "20258": "5111e24391516bcc7ec8630915dfda9c3d8ae53d", "20277": "6cfd47d7970198647962e2b00bd15ba010617c4a", "20280": "813219fffcca1cee89b7b0efd385cc624f56dd55", "20291": "016f7a167ccba3de2145f63eddb52b695660624c", "20349": "ce000ef7a815854cb1c62c824f971d951e35acb6", "20364": "025f6f9e73572a4aa608ac6e90bb1d7bc557e51f", "20389": "fcace96d088e75ce20d2d58d7f921eed06fe0ee8", "20396": "1713bbd7462d47ff67dd42bdaa5172a9bb31ad05", "20405": "f1814d743b53425cac2cbecf4bae07aeef6f835b", "20435": "994b2224ad1c455e25d112c66ea72ccd84fc4bd2", "20446": "d47f82738fbed7b7fdd6278acab3f206946a4edc", "20452": "346f8d4a57f0a73d6e1edabac6803a426511fdef", "20460": "87efe00713cd0330a7503907c64907af0e161065", "20500": "9f616ee302fdbe3cf100993c2e0a4fe66b28f161", "20502": "9cc14700031ed5f4dd620eb8d2a8825865f36634", "20508": "0445673ad157e887fd63c6a803386690205a951e", "20512": "0e2102057ad0d56eea50de132d69030c603df20a", "20537": "0a621a30988fd8c4959806ee0e9be5320b1895bd", "20541": "7e1969297b1f9a40371dfa38cdc09487efbb1084", "20547": "fdd5603af766f6a5ceb9c8ac03da6e78936385ff", "20556": "12b07bc2034bf41a567a5197fb95b7b05962092b", "20559": "544f80cbb04dc8f2b71d479b4476f59be3e38090", "20567": "fb02496456603181327bd58aa77ecc9c34c2b0a3", "20572": "02efd8ae2120908cf5a6d5ab4d95b41e5de13325", "20581": "bca01936d1aee69379463abd79141ed8fa12f3a5", "20584": "d1aafab5d10876694a97978a01e573bdb406a974", "20586": "dd9ee6fa0a2e8914049b3ac60aba88485cc5cc40", "20594": "409df25bd5d290c97146d507a2782b2f914e341d", "20608": "f26d31c5d676c05bd4d51e659b1bc8112fc70e2d", "20609": "7734d142394a380c3b6cde6a0f72ada51f12b5f1", "20614": "101ebbef0d7605fe5dfef3d2983cbe7982ab0bf2", "20624": "12bdac11610c3299221323ecae4358075776cbe5", "20641": "729a78b70ec13a83a3898c49c413d1abfcd5eb61", "20644": "c59783a5739dd7f2d25ead7549bb95c642d69e9a", "20661": "b1b70026bc50a63908d43c05b35adcdf27305581", "20721": "6826b9d3c6a6ef13638ef4d6ec1c17d6493626cd", "20759": "1bb608340a5bcc0697f92583cd0d5469449ddfaa", "20761": "6cd44236efa5049faf538b7a50efcca1c63b5182", "20766": "5f8309306e6353df685100d5cef45c7d2443beb3", "20771": "6df48fd62892055e3badc0270cc70f3795baad07", "20802": "0ccee5dde9f63176c46c0255f7c242867d5ab69d", "20827": "1ec9f43eea32e0800a6efe4a318702256b137372", "20882": "fc9c8f7fa5fb5396bccfb00505f332c61b48deb0", "20905": "2591bc8fcd957db37ab8edaf46e020ea9e27f5df", "20930": "c435c121468d9e73c165f849ca9a6e7d0d02050e", "20931": "39e30745ce3d405b8bd90637f1411f9f6f3cd5fc", "20932": "a4d7933b2b7e6b3c96a3c2f01f0fc21352820c4d", "20933": "08b801f1f8598c4e44680b4a75c232ed92db0262", "20953": "e8857ce0d8c13262137dd48e34111e2eaae045bb", "20969": "6cfaaa84812a1e86fb66235e43bf34afdf14a816", "20980": "26b5507cb3a3dc01f62a61dbd7b137c8ff55ef55", "20984": "5f149c0f81bc9d690662faf7d8052d46bf62804d", "20992": "1996bc25401d5060e23dbc23f851fd980c8cdaaf", "21002": "1605e178eaf8ce62a6d709ea381444cc7124c983", "21036": "a37edbc07b48eb9448a427635a30d55a80759b03", "21050": "05355b103817dcd7aae0839a485b7ce28fb354a5", "21066": "7962b0ee212419f5996836e48a2edc135d68923d", "21074": "cd2fca6cda48e32097d85bf565ca908554469986", "21092": "eb991edf8b94de564436ac6f4bffcf6005f8f0c8", "21099": "54b3ab1282776609fa50b013a0b685e0301b6336", "21106": "54658d7c651e9427cca3f5fe395f37e6354185ec", "21117": "3e3cb775e271264fd40217248887c98bbd37c30c", "21124": "32aba60331d6a6789e4656fb5c772d913e17389c", "21156": "aedf2f719d1b328578937a088c8becb4ceff294b", "21192": "95328adbabfce8826b15fd8bbde773ba0a28d804", "21197": "3976fda03d475d75fc3dced5c087bd4732563d46", "21221": "91ab5fa2d8ca3f70bdf435cc956c1aaa028c20ee", "21235": "7ec4effc263a98ba436e3980225a8af937e47333", "21241": "f9a228ce55f9be6bd5c57341bb4490b79df984e6", "21249": "2c0e734466d5adce67fd63a6e2406ea88ca52594", "21256": "2b370fe437a6523cbaf4925e1bf987b733cba6a2", "21298": "b50f30c03e2b2c513b037b01c3ad904a86681559", "21302": "0ffebc01a017c5c8b9d8dd15f1613aaf41fc566f", "21304": "f534d904b0b2823d6432ccfad06e4c17dfd631a8", "21311": "7a75bbe12d25ac411c3c5413c08912a493cbce04", "21316": "fb2a49751a5a2bd59a98032f7992a724e89be8b5", "21320": "9fe60cb21a3ddbf3c6cb26e17637e36ecf78e2e7", "21324": "c2469cbad9b1a23e6565a6084c59ff519dafe516", "21328": "e100a4c8bbcd71d16404fc2e000ef8227f1dec72", "21353": "2c3b0c018a37a94ae93ceb4fb481921d8329465e", "21356": "5fa877769da3b99990eb5f1ae9f6d826a34f1494", "21361": "8bf63cb4118adb790aa6f6592410eb10060cef9c", "21393": "0774fd3266b6f2d89e9442df4ea882ec5f995adc", "21398": "d710f2e4e2b16c80a5cbecd5b0125c9c6bd8d2e9", "21411": "3e565f3243c677de4cb4e9fa0b34cf0ee47ec13c", "21420": "25df3a2834be2498998fcb607b697689bc9ddb80", "21427": "69fef61c9a6dd09b3c3e5f11203858589c6c0944", "21437": "d63946c557a26ffeba5ebf3fbe195545695793d9", "21441": "431f3f57dd0e0546ee0c8ad80865d84ab3d54b42", "21450": "69e779fcdaccab046a7ea65b515dc14402e1650d", "21459": "104b04959e65dafde9af2c32252d0eb9c1f2ef1c", "21461": "3530ecc9cada009b454decb7063973de5bf5f2b0", "21465": "729ffe615eafac41dea14ec416e47973b180c361", "21470": "4c6e1eae61bf23f004f4a7a0190db86eb0e3d43b", "21497": "bb59a1c87254a254caf3295a320de44c58685a0c", "21502": "4116f0f9ad8a73ada0acc343f8cb809bfffb8ce7", "21508": "47f87af52b37fe0d8d5f39745fe5b4fd2264bc1a", "21523": "b11d943404c258c11870ea2944099ec7e8b32222", "21539": "c804126da2b6c771f804cb82ba4eb10183fc1b49", "21543": "e5adc70295a0d408d7fd911f46bb9d177a2ea361", "21558": "a4120d70bd631ad2add228fdb1f86706bc5f2339", "21582": "044a5cbadb8b448be4ff04c0af84e103e8cfa3e7", "21607": "e1a887c99f9899b1c829bbb954792db6ef95ee57", "21647": "e9079c305d3b3d44b971b496efc59c9b251460f4", "21654": "88d91da27d38c51ece2ff1ec1d112e94e9b8645d", "21662": "e69fdc2d5292fb5974179bfd04c93f39e9cabdef", "21670": "4e104de3c113c01688a0ed06b2f2cb1a958fce44", "21678": "68c2b3a92f1bc49c1061667aeffeca50e10ca418", "21740": "e3199ed032b6fae9d784edaef0e5162dd5a74c48", "21762": "63c0cb80ffcc93a68767f3dee9fc98495fa16a21", "21775": "70c524966c5f39c52b3d1e647bbe635a5033e7cb", "21807": "f34a339d7608f211be50821db33db55031276d42", "21834": "06ba7740e96d18b21c0f7ec1ba616019e5648ae9", "21870": "691ffdf7fe50214cf944783357fdcb5c5054e9c2", "21899": "10f8ec4906e710d1512d9c600821d088c13d191a", "21907": "5ebbce669e43c296781ce8c25b4beb9a287ba754", "21936": "ec4cf940d3adce760bafda6f2cfbe8f8aafb0d43", "21944": "c58974682673c449cb39987ba8b9a8926a05ac68", "21999": "a795f10ac18c78f8212a1a1ff56258d681bff955", "22002": "08514697a96556eb8b3b63f4ad885ed940d6b879", "22005": "7f8d958a1f35fd0c6c77ac0fd25227abf19eba52", "22018": "123993c25ca1b6062871899cdc2692ff1af88ec4", "22020": "cb102a2a4fab8e740f08ce66f3ce510dcfa866b5", "22056": "0459dbede620d36365baedf31f70a2748480d086", "22067": "17cd323874fab5b33d98bcdd47a8a23635a9ae99"}, "revision_to_date": {"17": 1488947030000, "451": 1495468169000, "867": 1501940680000, "985": 1503652548000, "986": 1503660746000, "1023": 1504169436000, "1099": 1505479548000, "1383": 1508254735000, "1405": 1508772666000, "1434": 1509704747000, "1493": 1510939204000, "1548": 1512420589000, "1611": 1512678476000, "1703": 1513592275000, "1719": 1513763548000, "1790": 1513974780000, "1793": 1513977192000, "1858": 1515410839000, "1860": 1515414281000, "1865": 1515431139000, "1870": 1515523066000, "1887": 1516630651000, "1892": 1516967870000, "1899": 1517219684000, "2936": 1518446831000, "3058": 1520347883000, "3112": 1520968403000, "3383": 1523442074000, "3471": 1523900871000, "3514": 1524067724000, "3807": 1525715330000, "3852": 1526066850000, "3875": 1526372306000, "3902": 1526899172000, "3947": 1527581142000, "4030": 1528721123000, "4278": 1530519021000, "4346": 1530868113000, "4400": 1532005274000, "5427": 1538645753000, "5454": 1538740147000, "7808": 1545217568000, "9293": 1551727859000, "11737": 1556720910000, "11904": 1556830196000, "12826": 1559154197000, "13364": 1560544881000, "15525": 1566483219000, "16679": 1570812840000, "16795": 1571236716000, "18605": 1575950023000, "19119": 1578430181000, "19887": 1581022798000, "19889": 1581027789000, "19896": 1581092473000, "19898": 1581094700000, "19913": 1581218998000, "19930": 1581437101000, "19968": 1581530145000, "19989": 1581539975000, "19998": 1581542540000, "20005": 1581547985000, "20011": 1581607038000, "20012": 1581608988000, "20017": 1581611477000, "20051": 1581617099000, "20064": 1581622457000, "20073": 1581627420000, "20086": 1581632970000, "20091": 1581636936000, "20095": 1581639856000, "20098": 1581642299000, "20105": 1581644361000, "20128": 1581687554000, "20154": 1581693738000, "20165": 1581699596000, "20170": 1581703870000, "20185": 1581708732000, "20191": 1581712437000, "20196": 1581714403000, "20199": 1581717973000, "20251": 1582046045000, "20258": 1582050113000, "20277": 1582114529000, "20280": 1582115942000, "20291": 1582122630000, "20349": 1582213075000, "20364": 1582220276000, "20389": 1582304215000, "20396": 1582307078000, "20405": 1582323012000, "20435": 1582519174000, "20446": 1582555419000, "20452": 1582559384000, "20460": 1582564460000, "20500": 1582607853000, "20502": 1582610860000, "20508": 1582623669000, "20512": 1582644296000, "20537": 1582683309000, "20541": 1582707893000, "20547": 1582715560000, "20556": 1582726619000, "20559": 1582728616000, "20567": 1582734156000, "20572": 1582736253000, "20581": 1582754893000, "20584": 1582756736000, "20586": 1582758337000, "20594": 1582769646000, "20608": 1582813235000, "20609": 1582813439000, "20614": 1582818953000, "20624": 1582832314000, "20641": 1582880706000, "20644": 1582900485000, "20661": 1582926892000, "20721": 1583148644000, "20759": 1583244171000, "20761": 1583246306000, "20766": 1583256332000, "20771": 1583258099000, "20802": 1583278521000, "20827": 1583332427000, "20882": 1583423908000, "20905": 1583427834000, "20930": 1583495916000, "20931": 1583496016000, "20932": 1583496049000, "20933": 1583427834000, "20953": 1583527433000, "20969": 1583533246000, "20980": 1583762298000, "20984": 1583764210000, "20992": 1583766631000, "21002": 1583771729000, "21036": 1583851516000, "21050": 1583855057000, "21066": 1583862363000, "21074": 1583866262000, "21092": 1583875368000, "21099": 1583879774000, "21106": 1583884180000, "21117": 1583931837000, "21124": 1583937931000, "21156": 1583957675000, "21192": 1583968365000, "21197": 1583982513000, "21221": 1584025693000, "21235": 1584030993000, "21241": 1584035072000, "21249": 1584038450000, "21256": 1584044991000, "21298": 1584136342000, "21302": 1584138252000, "21304": 1584138521000, "21311": 1584139882000, "21316": 1584141907000, "21320": 1584143827000, "21324": 1584145241000, "21328": 1584157570000, "21353": 1584343713000, "21356": 1584345893000, "21361": 1584363365000, "21393": 1584397336000, "21398": 1584399408000, "21411": 1584453656000, "21420": 1584457453000, "21427": 1584460534000, "21437": 1584463986000, "21441": 1584467152000, "21450": 1584470885000, "21459": 1584475153000, "21461": 1584477556000, "21465": 1584480596000, "21470": 1584485839000, "21497": 1584545186000, "21502": 1584559362000, "21508": 1584588954000, "21523": 1584630700000, "21539": 1584647006000, "21543": 1584649881000, "21558": 1584695617000, "21582": 1584718651000, "21607": 1584724774000, "21647": 1584879354000, "21654": 1584963042000, "21662": 1584984435000, "21670": 1584998183000, "21678": 1585050236000, "21740": 1585148578000, "21762": 1585162917000, "21775": 1585171781000, "21807": 1585239522000, "21834": 1585254135000, "21870": 1585257214000, "21899": 1585314474000, "21907": 1585327188000, "21936": 1585363133000, "21944": 1585372550000, "21999": 1585522062000, "22002": 1585523862000, "22005": 1585526935000, "22018": 1585538624000, "22020": 1585545258000, "22056": 1585565917000, "22067": 1585572616000}, "params": {"arch": ["x86_64"], "cpu": ["Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz"], "machine": ["qiskit-benchmarking"], "num_cpu": ["4"], "os": ["Ubuntu 18.04"], "ram": ["16 GB"], "python": ["3.6"], "branch": ["master"]}, "graph_param_list": [{"arch": "x86_64", "cpu": "Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz", "machine": "qiskit-benchmarking", "num_cpu": "4", "os": "Ubuntu 18.04", "ram": "16 GB", "python": "3.6", "branch": "master"}], "benchmarks": {"assembler.AssemblerBenchmarks.time_assemble_circuit": {"code": "class AssemblerBenchmarks:\n    def time_assemble_circuit(self, _, __, ___):\n        assemble(self.circuits)\n\n    def setup(self, n_qubits, depth, number_of_circuits):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, seed=seed)\n        self.circuits = [self.circuit] * number_of_circuits", "min_run_count": 2, "name": "assembler.AssemblerBenchmarks.time_assemble_circuit", "number": 0, "param_names": ["n_qubits", "depth", "number of circuits"], "params": [["1", "2", "5", "8"], ["8", "128", "1024", "2048", "4096"], ["1", "5", "10", "50", "100"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "2", "warmup_time": -1}, "assembler.DisassemblerBenchmarks.time_disassemble_circuit": {"code": "class DisassemblerBenchmarks:\n    def time_disassemble_circuit(self, _, __, ___):\n        disassemble(self.qobj)\n\n    def setup(self, n_qubits, depth, number_of_circuits):\n        seed = 424242\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, seed=seed)\n        self.circuits = [self.circuit] * number_of_circuits\n        self.qobj = assemble(self.circuits)", "min_run_count": 2, "name": "assembler.DisassemblerBenchmarks.time_disassemble_circuit", "number": 0, "param_names": ["n_qubits", "depth", "number of circuits"], "params": [["1", "2", "5", "8"], ["8", "128", "1024", "2048", "4096"], ["1", "5", "10", "50", "100"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "f2d251aadd6f4afbac5b4d284f0e465e7bbb352a7c4924bde41d7df7afa9a510", "warmup_time": -1}, "circuit_construction.CircuitConstructionBench.time_circuit_construction": {"code": "class CircuitConstructionBench:\n    def time_circuit_construction(self, width, gates):\n        build_circuit(width, gates)\n\n    def setup(self, width, gates):\n        self.empty_circuit = build_circuit(width, 0)\n        self.sample_circuit = build_circuit(width, gates)", "min_run_count": 2, "name": "circuit_construction.CircuitConstructionBench.time_circuit_construction", "number": 0, "param_names": ["width", "gates"], "params": [["1", "2", "5", "8", "14", "20"], ["8", "128", "2048", "8192", "32768", "131072"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "618ff14a5cecdab61b2cf1a966d2f0c9d83fd647c9b6a2b9f7da3f28df564d83", "warmup_time": -1}, "circuit_construction.CircuitConstructionBench.time_circuit_copy": {"code": "class CircuitConstructionBench:\n    def time_circuit_copy(self, _, __):\n        self.sample_circuit.copy()\n\n    def setup(self, width, gates):\n        self.empty_circuit = build_circuit(width, 0)\n        self.sample_circuit = build_circuit(width, gates)", "min_run_count": 2, "name": "circuit_construction.CircuitConstructionBench.time_circuit_copy", "number": 0, "param_names": ["width", "gates"], "params": [["1", "2", "5", "8", "14", "20"], ["8", "128", "2048", "8192", "32768", "131072"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "819a4a3af4a81f52172d42e2c9328201830402f8a6845ebed80689fb6b156cb6", "warmup_time": -1}, "circuit_construction.CircuitConstructionBench.time_circuit_extend": {"code": "class CircuitConstructionBench:\n    def time_circuit_extend(self, _, __):\n        self.empty_circuit.extend(self.sample_circuit)\n\n    def setup(self, width, gates):\n        self.empty_circuit = build_circuit(width, 0)\n        self.sample_circuit = build_circuit(width, gates)", "min_run_count": 2, "name": "circuit_construction.CircuitConstructionBench.time_circuit_extend", "number": 0, "param_names": ["width", "gates"], "params": [["1", "2", "5", "8", "14", "20"], ["8", "128", "2048", "8192", "32768", "131072"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "2c6beb960a323872e34a82407f9c892f21c8664c0beafa45ac85bb4d4afaeae4", "warmup_time": -1}, "converters.ConverterBenchmarks.time_ast_to_circuit": {"code": "class ConverterBenchmarks:\n    def time_ast_to_circuit(self, *_):\n        converters.ast_to_dag(self.qasm)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        # NOTE: Remove the benchmarks larger than 20x2048 and 14x8192, this is\n        # a tradeoff for speed of benchmarking, creating circuits this size\n        # takes more time than is worth it for benchmarks that take a couple\n        # seconds\n        if n_qubits >= 20:\n            if depth >= 2048:\n                raise NotImplementedError\n        elif n_qubits == 14:\n            if depth > 2048:\n                raise NotImplementedError\n        self.qc = random_circuit(n_qubits, depth, measure=True,\n                                 conditional=True, seed=seed)\n        self.dag = converters.circuit_to_dag(self.qc)\n        self.qasm = qasm.Qasm(data=self.qc.qasm()).parse()", "min_run_count": 2, "name": "converters.ConverterBenchmarks.time_ast_to_circuit", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["1", "2", "5", "8", "14", "20", "32", "53"], ["8", "128", "2048", "8192"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "d95bdb3924c6c9881da23a89b92fbf5a756fd9ab48c3bc34554c34404919291d", "warmup_time": -1}, "converters.ConverterBenchmarks.time_circuit_to_dag": {"code": "class ConverterBenchmarks:\n    def time_circuit_to_dag(self, *_):\n        converters.circuit_to_dag(self.qc)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        # NOTE: Remove the benchmarks larger than 20x2048 and 14x8192, this is\n        # a tradeoff for speed of benchmarking, creating circuits this size\n        # takes more time than is worth it for benchmarks that take a couple\n        # seconds\n        if n_qubits >= 20:\n            if depth >= 2048:\n                raise NotImplementedError\n        elif n_qubits == 14:\n            if depth > 2048:\n                raise NotImplementedError\n        self.qc = random_circuit(n_qubits, depth, measure=True,\n                                 conditional=True, seed=seed)\n        self.dag = converters.circuit_to_dag(self.qc)\n        self.qasm = qasm.Qasm(data=self.qc.qasm()).parse()", "min_run_count": 2, "name": "converters.ConverterBenchmarks.time_circuit_to_dag", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["1", "2", "5", "8", "14", "20", "32", "53"], ["8", "128", "2048", "8192"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "1d6d3654e3de6b884df94f6206d04ba95fb52e6d61d67c913269f324b4871382", "warmup_time": -1}, "converters.ConverterBenchmarks.time_circuit_to_instruction": {"code": "class ConverterBenchmarks:\n    def time_circuit_to_instruction(self, *_):\n        converters.circuit_to_instruction(self.qc)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        # NOTE: Remove the benchmarks larger than 20x2048 and 14x8192, this is\n        # a tradeoff for speed of benchmarking, creating circuits this size\n        # takes more time than is worth it for benchmarks that take a couple\n        # seconds\n        if n_qubits >= 20:\n            if depth >= 2048:\n                raise NotImplementedError\n        elif n_qubits == 14:\n            if depth > 2048:\n                raise NotImplementedError\n        self.qc = random_circuit(n_qubits, depth, measure=True,\n                                 conditional=True, seed=seed)\n        self.dag = converters.circuit_to_dag(self.qc)\n        self.qasm = qasm.Qasm(data=self.qc.qasm()).parse()", "min_run_count": 2, "name": "converters.ConverterBenchmarks.time_circuit_to_instruction", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["1", "2", "5", "8", "14", "20", "32", "53"], ["8", "128", "2048", "8192"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "b2d36939ee94d79bdbb7bfb4622ea92ce467cfb111ed5ff3aa94a5360e63e94e", "warmup_time": -1}, "converters.ConverterBenchmarks.time_dag_to_circuit": {"code": "class ConverterBenchmarks:\n    def time_dag_to_circuit(self, *_):\n        converters.dag_to_circuit(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        # NOTE: Remove the benchmarks larger than 20x2048 and 14x8192, this is\n        # a tradeoff for speed of benchmarking, creating circuits this size\n        # takes more time than is worth it for benchmarks that take a couple\n        # seconds\n        if n_qubits >= 20:\n            if depth >= 2048:\n                raise NotImplementedError\n        elif n_qubits == 14:\n            if depth > 2048:\n                raise NotImplementedError\n        self.qc = random_circuit(n_qubits, depth, measure=True,\n                                 conditional=True, seed=seed)\n        self.dag = converters.circuit_to_dag(self.qc)\n        self.qasm = qasm.Qasm(data=self.qc.qasm()).parse()", "min_run_count": 2, "name": "converters.ConverterBenchmarks.time_dag_to_circuit", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["1", "2", "5", "8", "14", "20", "32", "53"], ["8", "128", "2048", "8192"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "4c114285ee38fcb7187f649f933d0d0cfafe587594af3033d743b9abebb824ce", "warmup_time": -1}, "import.QiskitImport.time_qiskit_import": {"code": "class QiskitImport:\n    def time_qiskit_import(self):\n        call((executable, '-c', 'import qiskit'))", "min_run_count": 2, "name": "import.QiskitImport.time_qiskit_import", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "42e6b138b789932416117cff732f281a3f426a69659f2f030fb62903990be365", "warmup_time": -1}, "isometry.IsometryTranspileBench.time_simulator_transpile": {"code": "class IsometryTranspileBench:\n    def time_simulator_transpile(self, *unused):\n        transpile(self.circuit, basis_gates=['u1', 'u3', 'u2', 'cx'],\n                  seed_transpiler=0)\n\n    def setup(self, m, n):\n        q = QuantumRegister(n)\n        qc = QuantumCircuit(q)\n        if not hasattr(qc, 'iso'):\n            raise NotImplementedError\n        iso = random_unitary(2 ** n, seed=0).data[:, 0:2 ** m]\n        if len(iso.shape) == 1:\n            iso = iso.reshape((len(iso), 1))\n        qc.iso(iso, q[:m], q[m:])\n        self.circuit = qc", "min_run_count": 2, "name": "isometry.IsometryTranspileBench.time_simulator_transpile", "number": 0, "param_names": ["number of input qubits", "number of output qubits"], "params": [["0", "1", "2", "3"], ["3", "4", "5", "6"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "cee6d5bc5430a022a9a8261150ae8e97d21ecad5cbc63f47b06d0df2f1c7093a", "warmup_time": -1}, "isometry.IsometryTranspileBench.track_cnot_counts": {"code": "class IsometryTranspileBench:\n    def track_cnot_counts(self, *unused):\n        circuit = transpile(self.circuit, basis_gates=['u1', 'u3', 'u2', 'cx'],\n                            seed_transpiler=0)\n        counts = circuit.count_ops()\n        cnot_count = counts.get('cx', 0)\n        return cnot_count\n\n    def setup(self, m, n):\n        q = QuantumRegister(n)\n        qc = QuantumCircuit(q)\n        if not hasattr(qc, 'iso'):\n            raise NotImplementedError\n        iso = random_unitary(2 ** n, seed=0).data[:, 0:2 ** m]\n        if len(iso.shape) == 1:\n            iso = iso.reshape((len(iso), 1))\n        qc.iso(iso, q[:m], q[m:])\n        self.circuit = qc", "name": "isometry.IsometryTranspileBench.track_cnot_counts", "param_names": ["number of input qubits", "number of output qubits"], "params": [["0", "1", "2", "3"], ["3", "4", "5", "6"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "b60c65500ec8d187fe4ca79f35ed3961f40c0b504ab5ceb525450eff98e3866a"}, "isometry.IsometryTranspileBench.track_cnot_counts_after_mapping_to_ibmq_16_melbourne": {"code": "class IsometryTranspileBench:\n    def track_cnot_counts_after_mapping_to_ibmq_16_melbourne(self, *unused):\n        coupling = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                    [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                    [11, 3], [11, 10], [11, 12], [12, 2], [13, 1], [13, 12]]\n        circuit = transpile(self.circuit, basis_gates=['u1', 'u3', 'u2', 'cx'],\n                            coupling_map=coupling, seed_transpiler=0)\n        counts = circuit.count_ops()\n        cnot_count = counts.get('cx', 0)\n        return cnot_count\n\n    def setup(self, m, n):\n        q = QuantumRegister(n)\n        qc = QuantumCircuit(q)\n        if not hasattr(qc, 'iso'):\n            raise NotImplementedError\n        iso = random_unitary(2 ** n, seed=0).data[:, 0:2 ** m]\n        if len(iso.shape) == 1:\n            iso = iso.reshape((len(iso), 1))\n        qc.iso(iso, q[:m], q[m:])\n        self.circuit = qc", "name": "isometry.IsometryTranspileBench.track_cnot_counts_after_mapping_to_ibmq_16_melbourne", "param_names": ["number of input qubits", "number of output qubits"], "params": [["0", "1", "2", "3"], ["3", "4", "5", "6"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "9b72b85b9334e6b1cec59098c51c92cefc12249ad6b3f05231f7b4b75dc2d504"}, "mapping_passes.PassBenchmarks.peakmem_apply_layout": {"code": "class PassBenchmarks:\n    def peakmem_apply_layout(self, _, __):\n        layout = ApplyLayout()\n        layout.property_set['layout'] = self.layout\n        layout.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_apply_layout", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "90b6b1e82c592efda4fb55ac13d05586452d88fdb09931148b08009477e8cdaa"}, "mapping_passes.PassBenchmarks.peakmem_basic_swap": {"code": "class PassBenchmarks:\n    def peakmem_basic_swap(self, _, __):\n        swap = BasicSwap(self.coupling_map)\n        swap.property_set['layout'] = self.layout\n        swap.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_basic_swap", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "4909af6223f71254667df7c7312975c7e741bd965fbd003b4b63039541e27cc0"}, "mapping_passes.PassBenchmarks.peakmem_check_cx_direction": {"code": "class PassBenchmarks:\n    def peakmem_check_cx_direction(self, _, __):\n        CheckCXDirection(self.coupling_map).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_check_cx_direction", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "036c7bb6aa4a326846039ad0cd105d63bbf0ed1619b2d6b34f50ee0e96b9bbba"}, "mapping_passes.PassBenchmarks.peakmem_check_map": {"code": "class PassBenchmarks:\n    def peakmem_check_map(self, _, __):\n        CheckMap(self.coupling_map).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_check_map", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "8647c96a346f608105ad62879e19129300a03c6c65e24d65ccccdb0d49284ffd"}, "mapping_passes.PassBenchmarks.peakmem_csp_layout": {"code": "class PassBenchmarks:\n    def peakmem_csp_layout(self, _, __):\n        CSPLayout(self.coupling_map, seed=42).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_csp_layout", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "18000592cda5d6454139cafaf48a3023a2b4399629077fb97052db27042ff4b6"}, "mapping_passes.PassBenchmarks.peakmem_cxdirection": {"code": "class PassBenchmarks:\n    def peakmem_cxdirection(self, _, __):\n        CXDirection(self.coupling_map).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_cxdirection", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "9d991a3800d4d642b58d2c5853a26faca0656cd21e821a815f1660471f052044"}, "mapping_passes.PassBenchmarks.peakmem_dense_layout": {"code": "class PassBenchmarks:\n    def peakmem_dense_layout(self, _, __):\n        DenseLayout(self.coupling_map).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_dense_layout", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "3825e1d5c53877cc9207c0d5cfdbf16ee7f0374cf172f4752ace68ccf165848d"}, "mapping_passes.PassBenchmarks.peakmem_enlarge_with_ancilla": {"code": "class PassBenchmarks:\n    def peakmem_enlarge_with_ancilla(self, _, __):\n        ancilla = EnlargeWithAncilla()\n        ancilla.property_set['layout'] = self.layout\n        ancilla.run(self.full_ancilla_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_enlarge_with_ancilla", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "c166505de93d51a48aa9afbd1328e6283e0cc2c639bb2f419681b6070e06ff62"}, "mapping_passes.PassBenchmarks.peakmem_full_ancilla_allocation": {"code": "class PassBenchmarks:\n    def peakmem_full_ancilla_allocation(self, _, __):\n        ancilla = FullAncillaAllocation(self.coupling_map)\n        ancilla.property_set['layout'] = self.layout\n        ancilla.run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_full_ancilla_allocation", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "9375293b9eda1dfba220414713f720baa8aed29cb58b7fd895512874ecb4119c"}, "mapping_passes.PassBenchmarks.peakmem_layout_2q_distance": {"code": "class PassBenchmarks:\n    def peakmem_layout_2q_distance(self, _, __):\n        layout = Layout2qDistance(self.coupling_map)\n        layout.property_set['layout'] = self.layout\n        layout.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_layout_2q_distance", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "8ca589070cb93ac473c7707534df8ee74a48602e169e019ea8b4cb462570fed5"}, "mapping_passes.PassBenchmarks.peakmem_noise_adaptive_layout": {"code": "class PassBenchmarks:\n    def peakmem_noise_adaptive_layout(self, _, __):\n        NoiseAdaptiveLayout(self.backend_props).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_noise_adaptive_layout", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "eff91397a9b4113048b6a200a055b3038c8628ff88c71e2e06d9e3fbc7265cc3"}, "mapping_passes.PassBenchmarks.peakmem_set_layout": {"code": "class PassBenchmarks:\n    def peakmem_set_layout(self, _, __):\n        SetLayout(self.layout).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_set_layout", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "56876597751983b1afe45600d7b2555c9077335093b2185d12a7b74728ef8159"}, "mapping_passes.PassBenchmarks.peakmem_stochastic_swap": {"code": "class PassBenchmarks:\n    def peakmem_stochastic_swap(self, _, __):\n        swap = StochasticSwap(self.coupling_map, seed=42)\n        swap.property_set['layout'] = self.layout\n        swap.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_stochastic_swap", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "3d63853ee422c31338a5b0f8199453757bfbc61888506b2bb4f2e6a81dce4f02"}, "mapping_passes.PassBenchmarks.peakmem_trivial_layout": {"code": "class PassBenchmarks:\n    def peakmem_trivial_layout(self, _, __):\n        TrivialLayout(self.coupling_map).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.peakmem_trivial_layout", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "eeba9588bd35f896358e70707b80361417353cb7201a542db02e178a3c2c9726"}, "mapping_passes.PassBenchmarks.time_apply_layout": {"code": "class PassBenchmarks:\n    def time_apply_layout(self, _, __):\n        layout = ApplyLayout()\n        layout.property_set['layout'] = self.layout\n        layout.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_apply_layout", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "da136eacec02f328545be4682ff862b456394212a1e58a6ca46a99f4cbf36051", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_basic_swap": {"code": "class PassBenchmarks:\n    def time_basic_swap(self, _, __):\n        swap = BasicSwap(self.coupling_map)\n        swap.property_set['layout'] = self.layout\n        swap.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_basic_swap", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "38e8c8052b2059340b7dd73fec85567f1224b310f29fc26822501770df35c512", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_check_cx_direction": {"code": "class PassBenchmarks:\n    def time_check_cx_direction(self, _, __):\n        CheckCXDirection(self.coupling_map).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_check_cx_direction", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "8e1c73d9974574b7275b0835b1674e6779bdb7bb18fe5c341759688bb6e1984a", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_check_map": {"code": "class PassBenchmarks:\n    def time_check_map(self, _, __):\n        CheckMap(self.coupling_map).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_check_map", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "228683bda15aa0e633840c5cc0f7d87a94f232ca9f4e464f0fc542451c0c6d2e", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_csp_layout": {"code": "class PassBenchmarks:\n    def time_csp_layout(self, _, __):\n        CSPLayout(self.coupling_map, seed=42).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_csp_layout", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "4762ad628979ca5b7bcd2982266c35cab1f4b64c98d871b84cc7e0da04048b93", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_cxdirection": {"code": "class PassBenchmarks:\n    def time_cxdirection(self, _, __):\n        CXDirection(self.coupling_map).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_cxdirection", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "51a5102f51b57e4dd843e47b7ddb7e53860bf4a9d6585532471bf3a73c767593", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_dense_layout": {"code": "class PassBenchmarks:\n    def time_dense_layout(self, _, __):\n        DenseLayout(self.coupling_map).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_dense_layout", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "67fd146dba95d87c610e865b476b8be339d582e496869cca4113a72213faaa79", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_enlarge_with_ancilla": {"code": "class PassBenchmarks:\n    def time_enlarge_with_ancilla(self, _, __):\n        ancilla = EnlargeWithAncilla()\n        ancilla.property_set['layout'] = self.layout\n        ancilla.run(self.full_ancilla_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_enlarge_with_ancilla", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "b0cdbe35a5c98c5884c74cab325f188668cff1a611ff70502154ec121e4be4e1", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_full_ancilla_allocation": {"code": "class PassBenchmarks:\n    def time_full_ancilla_allocation(self, _, __):\n        ancilla = FullAncillaAllocation(self.coupling_map)\n        ancilla.property_set['layout'] = self.layout\n        ancilla.run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_full_ancilla_allocation", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "c451037a9a77b87c42d61f6e3d4ea82a0d7613ed178b60b7fc046816e37fb527", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_layout_2q_distance": {"code": "class PassBenchmarks:\n    def time_layout_2q_distance(self, _, __):\n        layout = Layout2qDistance(self.coupling_map)\n        layout.property_set['layout'] = self.layout\n        layout.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_layout_2q_distance", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "8b2c9fc3f37de7310dc03076124986e48c64e3750efc2b5b9eac70b696341327", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_noise_adaptive_layout": {"code": "class PassBenchmarks:\n    def time_noise_adaptive_layout(self, _, __):\n        NoiseAdaptiveLayout(self.backend_props).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_noise_adaptive_layout", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "2ea5a22798ca169bd932e37a59a8c3180cd69fe33786248ff0d0c41e6ed4daff", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_set_layout": {"code": "class PassBenchmarks:\n    def time_set_layout(self, _, __):\n        SetLayout(self.layout).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_set_layout", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "b8590e8206c3b405df6b1b978f95a9615de301ed394846840b53c9207f0988aa", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_stochastic_swap": {"code": "class PassBenchmarks:\n    def time_stochastic_swap(self, _, __):\n        swap = StochasticSwap(self.coupling_map, seed=42)\n        swap.property_set['layout'] = self.layout\n        swap.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_stochastic_swap", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "4ac83d734d795a8021aa8227d38e5179f9c529acadf54633a8baaa3211988280", "warmup_time": -1}, "mapping_passes.PassBenchmarks.time_trivial_layout": {"code": "class PassBenchmarks:\n    def time_trivial_layout(self, _, __):\n        TrivialLayout(self.coupling_map).run(self.fresh_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "min_run_count": 2, "name": "mapping_passes.PassBenchmarks.time_trivial_layout", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "7dac9b6ece7844ccb7d792ba595081660b37bfc6451a5d8af6e4c3ddb7fe5110", "warmup_time": -1}, "mapping_passes.PassBenchmarks.track_basic_swap_depth": {"code": "class PassBenchmarks:\n    def track_basic_swap_depth(self, _, __):\n        swap = BasicSwap(self.coupling_map)\n        swap.property_set['layout'] = self.layout\n        return swap.run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.track_basic_swap_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "33d2460e2317f77394c88cd48e377807398352c01a5a85f665199e49334fb600"}, "mapping_passes.PassBenchmarks.track_basic_swap_swap_count": {"code": "class PassBenchmarks:\n    def track_basic_swap_swap_count(self, _, __):\n        swap = BasicSwap(self.coupling_map)\n        swap.property_set['layout'] = self.layout\n        return swap.run(self.dag).depth().count_ops().get('swap')\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.track_basic_swap_swap_count", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "a1133a2eed7f84b21bc9f820e34a660aff599fa8954e5bf0bc4fa207cecb1e9e"}, "mapping_passes.PassBenchmarks.track_cxdirection_cnot_count": {"code": "class PassBenchmarks:\n    def track_cxdirection_cnot_count(self, _, __):\n        return CXDirection(\n            self.coupling_map).run(self.dag).count_ops().get('cx')\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.track_cxdirection_cnot_count", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "b64bb284dfa4099b3a4a059605028764f098c5cd6900580bfa39193126765301"}, "mapping_passes.PassBenchmarks.track_cxdirection_depth": {"code": "class PassBenchmarks:\n    def track_cxdirection_depth(self, _, __):\n        return CXDirection(self.coupling_map).run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.track_cxdirection_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "2e26aaa371612a09e4dda9686938f5fffdad23a1657ec90b9c86a547d8a5b4e2"}, "mapping_passes.PassBenchmarks.track_stochastic_swap_depth": {"code": "class PassBenchmarks:\n    def track_stochastic_swap_depth(self, _, __):\n        swap = StochasticSwap(self.coupling_map, seed=42)\n        swap.property_set['layout'] = self.layout\n        return swap.run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.track_stochastic_swap_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "b847117b1cdc9e935d069778d2fc6164eac25144b415061370b23e06e5d9db86"}, "mapping_passes.PassBenchmarks.track_stochastic_swap_swap_count": {"code": "class PassBenchmarks:\n    def track_stochastic_swap_swap_count(self, _, __):\n        swap = StochasticSwap(self.coupling_map, seed=42)\n        swap.property_set['layout'] = self.layout\n        return swap.run(self.dag).count_ops().get('swap')\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed,\n                                      max_operands=2)\n        self.fresh_dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'iid']\n        self.cmap = [[0, 1], [1, 0], [1, 2], [1, 6], [2, 1], [2, 3], [3, 2],\n                     [3, 4], [3, 8], [4, 3], [5, 6], [5, 10], [6, 1], [6, 5],\n                     [6, 7], [7, 6], [7, 8], [7, 12], [8, 3], [8, 7], [8, 9],\n                     [9, 8], [9, 14], [10, 5], [10, 11], [11, 10], [11, 12],\n                     [11, 16], [12, 7], [12, 11], [12, 13], [13, 12], [13, 14],\n                     [13, 18], [14, 9], [14, 13], [15, 16], [16, 11], [16, 15],\n                     [16, 17], [17, 16], [17, 18], [18, 13], [18, 17],\n                     [18, 19], [19, 18]]\n        self.coupling_map = CouplingMap(self.cmap)\n    \n        layout_pass = DenseLayout(self.coupling_map)\n        layout_pass.run(self.fresh_dag)\n        self.layout = layout_pass.property_set['layout']\n        full_ancilla_pass = FullAncillaAllocation(self.coupling_map)\n        full_ancilla_pass.property_set['layout'] = self.layout\n        self.full_ancilla_dag = full_ancilla_pass.run(self.fresh_dag)\n        enlarge_pass = EnlargeWithAncilla()\n        enlarge_pass.property_set['layout'] = self.layout\n        self.enlarge_dag = enlarge_pass.run(self.full_ancilla_dag)\n        apply_pass = ApplyLayout()\n        apply_pass.property_set['layout'] = self.layout\n        self.dag = apply_pass.run(self.enlarge_dag)\n        self.backend_props = fake_singapore.FakeSingapore().properties()", "name": "mapping_passes.PassBenchmarks.track_stochastic_swap_swap_count", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "749146efb21b3c2ff7a07a92ad991864b72609bf64ef87be3903b54e51a52bd4"}, "passes.Collect2QPassBenchmarks.peakmem_consolidate_blocks": {"code": "class Collect2QPassBenchmarks:\n    def peakmem_consolidate_blocks(self, _, __):\n        _pass = ConsolidateBlocks()\n        _pass.property_set['block_list'] = self.block_list\n        _pass.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        collect_blocks = Collect2qBlocks()\n        collect_blocks.run(self.dag)\n        self.block_list = collect_blocks.property_set['block_list']", "name": "passes.Collect2QPassBenchmarks.peakmem_consolidate_blocks", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "3dc538c7a05981c2d9e1cebd84053035137899055bb91cf7cbeded0576e4531e"}, "passes.Collect2QPassBenchmarks.time_consolidate_blocks": {"code": "class Collect2QPassBenchmarks:\n    def time_consolidate_blocks(self, _, __):\n        _pass = ConsolidateBlocks()\n        _pass.property_set['block_list'] = self.block_list\n        _pass.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        collect_blocks = Collect2qBlocks()\n        collect_blocks.run(self.dag)\n        self.block_list = collect_blocks.property_set['block_list']", "min_run_count": 2, "name": "passes.Collect2QPassBenchmarks.time_consolidate_blocks", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "8122b9601930f294db7e09197ff94013fa87f38f1973a8c4aff3539c48e10af2", "warmup_time": -1}, "passes.Collect2QPassBenchmarks.track_consolidate_blocks_depth": {"code": "class Collect2QPassBenchmarks:\n    def track_consolidate_blocks_depth(self, _, __):\n        _pass = ConsolidateBlocks()\n        _pass.property_set['block_list'] = self.block_list\n        return _pass.run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        collect_blocks = Collect2qBlocks()\n        collect_blocks.run(self.dag)\n        self.block_list = collect_blocks.property_set['block_list']", "name": "passes.Collect2QPassBenchmarks.track_consolidate_blocks_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "a6ec892e10142c3cbb878d6285c0a2ac0634fb37c9900112773215615635d96d"}, "passes.CommutativeAnalysisPassBenchmarks.peakmem_commutative_cancellation": {"code": "class CommutativeAnalysisPassBenchmarks:\n    def peakmem_commutative_cancellation(self, _, __):\n        _pass = CommutativeCancellation()\n        _pass.property_set['commutation_set'] = self.commutation_set\n        _pass.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        commutative_analysis = CommutationAnalysis()\n        commutative_analysis.run(\n            self.dag)\n        self.commutation_set = commutative_analysis.property_set[\n            'commutation_set']", "name": "passes.CommutativeAnalysisPassBenchmarks.peakmem_commutative_cancellation", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "81c7bd5c5cad45e759084ebefd5ab6a90b4a2e909ac07959ad8e8712204db512"}, "passes.CommutativeAnalysisPassBenchmarks.time_commutative_cancellation": {"code": "class CommutativeAnalysisPassBenchmarks:\n    def time_commutative_cancellation(self, _, __):\n        _pass = CommutativeCancellation()\n        _pass.property_set['commutation_set'] = self.commutation_set\n        _pass.run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        commutative_analysis = CommutationAnalysis()\n        commutative_analysis.run(\n            self.dag)\n        self.commutation_set = commutative_analysis.property_set[\n            'commutation_set']", "min_run_count": 2, "name": "passes.CommutativeAnalysisPassBenchmarks.time_commutative_cancellation", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "390576451c4cc0c9bc25f7b51b31e8823951423b52cea9c7c6ac5b70b1a91c75", "warmup_time": -1}, "passes.CommutativeAnalysisPassBenchmarks.track_commutative_cancellation_depth": {"code": "class CommutativeAnalysisPassBenchmarks:\n    def track_commutative_cancellation_depth(self, _, __):\n        _pass = CommutativeCancellation()\n        _pass.property_set['commutation_set'] = self.commutation_set\n        return _pass.run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        commutative_analysis = CommutationAnalysis()\n        commutative_analysis.run(\n            self.dag)\n        self.commutation_set = commutative_analysis.property_set[\n            'commutation_set']", "name": "passes.CommutativeAnalysisPassBenchmarks.track_commutative_cancellation_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "78718c13def1c9ae134bb6885f88cc634c8efff0c05c67d2bea0971b34a37e8b"}, "passes.PassBenchmarks.peakmem_barrier_before_final_measurement": {"code": "class PassBenchmarks:\n    def peakmem_barrier_before_final_measurement(self, _, __):\n        BarrierBeforeFinalMeasurements().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_barrier_before_final_measurement", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "d009744a69b7a33aae6115dd5e70e4fa5b94a709df0aaad2fc28d579404e97e9"}, "passes.PassBenchmarks.peakmem_collect_2q_blocks": {"code": "class PassBenchmarks:\n    def peakmem_collect_2q_blocks(self, _, __):\n        Collect2qBlocks().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_collect_2q_blocks", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "d892ada122d5e13b26aaf601abf8e32df6f5f4476bd73d9891f222606e7f413e"}, "passes.PassBenchmarks.peakmem_commutation_analysis": {"code": "class PassBenchmarks:\n    def peakmem_commutation_analysis(self, _, __):\n        CommutationAnalysis().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_commutation_analysis", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "883b43c38ee687eb2231352b95371762aef76293daf92e7789bf7d2a8cc78e6d"}, "passes.PassBenchmarks.peakmem_count_ops_longest_path": {"code": "class PassBenchmarks:\n    def peakmem_count_ops_longest_path(self, _, __):\n        CountOpsLongestPath().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_count_ops_longest_path", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "d05916181e20c1b0cb03073694485e66889d8edb4f872afc8974ef30e43a02a9"}, "passes.PassBenchmarks.peakmem_cx_cancellation": {"code": "class PassBenchmarks:\n    def peakmem_cx_cancellation(self, _, __):\n        CXCancellation().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_cx_cancellation", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "590d820d5dc5f279415f90f83dd1c5a8dd501b42ffeb3b3b9f70a1138823a5f5"}, "passes.PassBenchmarks.peakmem_dag_longest_path": {"code": "class PassBenchmarks:\n    def peakmem_dag_longest_path(self, _, __):\n        DAGLongestPath().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_dag_longest_path", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "27880e60e92cd244d01c32a81799ad8a4698ad0a674b9030e520d0180803f1ec"}, "passes.PassBenchmarks.peakmem_decompose_pass": {"code": "class PassBenchmarks:\n    def peakmem_decompose_pass(self, _, __):\n        Decompose().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_decompose_pass", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "96d89889fe58ae4196259d4b2d3002b2cc96659628c7541aa5ff07608b7f1caf"}, "passes.PassBenchmarks.peakmem_depth_pass": {"code": "class PassBenchmarks:\n    def peakmem_depth_pass(self, _, __):\n        Depth().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_depth_pass", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "0e4592bc10542a9823a555ff4448f1f3322c247715c019daf598413dda3398df"}, "passes.PassBenchmarks.peakmem_merge_adjacent_barriers": {"code": "class PassBenchmarks:\n    def peakmem_merge_adjacent_barriers(self, _, __):\n        MergeAdjacentBarriers().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_merge_adjacent_barriers", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "7b43680c017870fdb055f7fc0dd8204badcded2b6f4e39fd604ec17ab2d5ab78"}, "passes.PassBenchmarks.peakmem_num_tensor_factors": {"code": "class PassBenchmarks:\n    def peakmem_num_tensor_factors(self, _, __):\n        NumTensorFactors().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_num_tensor_factors", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "29d6d063b5f5b996e7b6cfcfe1fb1abb396c349a49dacad1b389dcc91a6a833f"}, "passes.PassBenchmarks.peakmem_optimize_swap_before_measure": {"code": "class PassBenchmarks:\n    def peakmem_optimize_swap_before_measure(self, _, __):\n        OptimizeSwapBeforeMeasure().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_optimize_swap_before_measure", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "24034bcffbefc6ac4dbd68cf7af5b0b196a39d8a3e21dd1cd5b865e93ae4d8b4"}, "passes.PassBenchmarks.peakmem_remove_diagonal_gates_before_measurement": {"code": "class PassBenchmarks:\n    def peakmem_remove_diagonal_gates_before_measurement(self, _, __):\n        RemoveDiagonalGatesBeforeMeasure().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_remove_diagonal_gates_before_measurement", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "824f24d1ebb9349e681330119ee04339d3ecbe16ec8044768c00d2ed74d534cc"}, "passes.PassBenchmarks.peakmem_remove_final_measurements": {"code": "class PassBenchmarks:\n    def peakmem_remove_final_measurements(self, _, __):\n        RemoveFinalMeasurements().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_remove_final_measurements", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "5c15c7b2911c17b9b6d381728049239dafe81a34648edc055f0cc2020f337348"}, "passes.PassBenchmarks.peakmem_resoure_optimization": {"code": "class PassBenchmarks:\n    def peakmem_resoure_optimization(self, _, __):\n        ResourceEstimation().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_resoure_optimization", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "9ca59fc1cdbed19db1d90790a085453b098aafdbe1091a398c9c6e70b6b84afa"}, "passes.PassBenchmarks.peakmem_size_pass": {"code": "class PassBenchmarks:\n    def peakmem_size_pass(self, _, __):\n        Size().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_size_pass", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "fd4efff47094a8caba14fe0f7f5ffe152d6f7c842cccf71997b0f856b238c738"}, "passes.PassBenchmarks.peakmem_unroll_3q_or_more": {"code": "class PassBenchmarks:\n    def peakmem_unroll_3q_or_more(self, _, __):\n        Unroll3qOrMore().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_unroll_3q_or_more", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "cce361435a4898f7b54e6e25b3158b7892b93ca0205a8d72fc8a13801925fec2"}, "passes.PassBenchmarks.peakmem_unroller": {"code": "class PassBenchmarks:\n    def peakmem_unroller(self, _, __):\n        Unroller(self.basis_gates).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_unroller", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "9a2aac7b43ed9ecad06be67c32a824dd06b344dcec1f188a9772d3bc1e59b4e9"}, "passes.PassBenchmarks.peakmem_width_pass": {"code": "class PassBenchmarks:\n    def peakmem_width_pass(self, _, __):\n        Width().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.peakmem_width_pass", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "2362f2a077b1ca5a714b0e44d10e9ad51c21121a9d0dd16cdb25a256a3e38605"}, "passes.PassBenchmarks.time_barrier_before_final_measurements": {"code": "class PassBenchmarks:\n    def time_barrier_before_final_measurements(self, _, __):\n        BarrierBeforeFinalMeasurements().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_barrier_before_final_measurements", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "4c9707a42e08efa6d58ff79073ced5e8a5729b1e90bc164f96571068467dc4e1", "warmup_time": -1}, "passes.PassBenchmarks.time_collect_2q_blocks": {"code": "class PassBenchmarks:\n    def time_collect_2q_blocks(self, _, __):\n        Collect2qBlocks().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_collect_2q_blocks", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "a0e1406e18fb4b66ea67e1d92c63981041ac759dea4a7d3c860f03880216e64c", "warmup_time": -1}, "passes.PassBenchmarks.time_commutation_analysis": {"code": "class PassBenchmarks:\n    def time_commutation_analysis(self, _, __):\n        CommutationAnalysis().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_commutation_analysis", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "31d4a5a06d78699133170a2c52b9a90d6a72c5cd99b966988bc6c9228795a7fb", "warmup_time": -1}, "passes.PassBenchmarks.time_count_ops_longest_path": {"code": "class PassBenchmarks:\n    def time_count_ops_longest_path(self, _, __):\n        CountOpsLongestPath().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_count_ops_longest_path", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "23b8e057d4a3f15ff302b25d17f230a6b5274f91ed5cc0c5821897d1afe9aef4", "warmup_time": -1}, "passes.PassBenchmarks.time_count_ops_pass": {"code": "class PassBenchmarks:\n    def time_count_ops_pass(self, _, __):\n        CountOps().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_count_ops_pass", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "2d8a2bcbf68d9fd0b813218c4e28a0afa230ee55070a8a7e2a9e9e19fc74ea41", "warmup_time": -1}, "passes.PassBenchmarks.time_cx_cancellation": {"code": "class PassBenchmarks:\n    def time_cx_cancellation(self, _, __):\n        CXCancellation().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_cx_cancellation", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "5e97c6f5b788dbeeec72e5676a526a020c802b0e9bad93cb9a91ed487ad9a9fe", "warmup_time": -1}, "passes.PassBenchmarks.time_dag_longest_path": {"code": "class PassBenchmarks:\n    def time_dag_longest_path(self, _, __):\n        DAGLongestPath().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_dag_longest_path", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "db2d35b6c270ea57e9d311b6c98e60abf104dd3f7f47b117c366bd44fb39bec2", "warmup_time": -1}, "passes.PassBenchmarks.time_decompose_pass": {"code": "class PassBenchmarks:\n    def time_decompose_pass(self, _, __):\n        Decompose().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_decompose_pass", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "72f6b8df337b29346c568b9517b279b992211daea12cae0bab70a7a6eb7229de", "warmup_time": -1}, "passes.PassBenchmarks.time_depth_pass": {"code": "class PassBenchmarks:\n    def time_depth_pass(self, _, __):\n        Depth().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_depth_pass", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "9c82ab6243c72751a93c31a4521970505dac8e97aa3c6aa694c45fb7dc09446d", "warmup_time": -1}, "passes.PassBenchmarks.time_merge_adjacent_barriers": {"code": "class PassBenchmarks:\n    def time_merge_adjacent_barriers(self, _, __):\n        MergeAdjacentBarriers().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_merge_adjacent_barriers", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "2197fac50ec07c051af76927284e89b651212fa5b305edfba6681398a727b471", "warmup_time": -1}, "passes.PassBenchmarks.time_num_tensor_factors": {"code": "class PassBenchmarks:\n    def time_num_tensor_factors(self, _, __):\n        NumTensorFactors().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_num_tensor_factors", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "f4345bdd954d00fd7218eaaf6d4f78917cf8d6842ccfb5a8393289fec11fb285", "warmup_time": -1}, "passes.PassBenchmarks.time_optimize_swap_before_measure": {"code": "class PassBenchmarks:\n    def time_optimize_swap_before_measure(self, _, __):\n        OptimizeSwapBeforeMeasure().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_optimize_swap_before_measure", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "45eae9e52635106fd37ae46b3045790d9ac021050db448039d7f4088356b42ef", "warmup_time": -1}, "passes.PassBenchmarks.time_remove_diagonal_gates_before_measurement": {"code": "class PassBenchmarks:\n    def time_remove_diagonal_gates_before_measurement(self, _, __):\n        RemoveDiagonalGatesBeforeMeasure().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_remove_diagonal_gates_before_measurement", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "5cf6f9c49a19d1b6bdb0fe37cf938e0fd19055462dac50c3f74c91dc515c45f9", "warmup_time": -1}, "passes.PassBenchmarks.time_remove_final_measurements": {"code": "class PassBenchmarks:\n    def time_remove_final_measurements(self, _, __):\n        RemoveFinalMeasurements().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_remove_final_measurements", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "ba42803f018903ca69c3dadd776b35a6877f90f1f83abea64057739dc5424643", "warmup_time": -1}, "passes.PassBenchmarks.time_remove_reset_in_zero_state": {"code": "class PassBenchmarks:\n    def time_remove_reset_in_zero_state(self, _, __):\n        RemoveResetInZeroState().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_remove_reset_in_zero_state", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "5b7592b1ccb0098fbaa17ff945863253e66b98f9dc885e613d045bc025c0c70b", "warmup_time": -1}, "passes.PassBenchmarks.time_resource_optimization": {"code": "class PassBenchmarks:\n    def time_resource_optimization(self, _, __):\n        ResourceEstimation().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_resource_optimization", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "3acd87432ea863d48557e8ce2c234e9f6adddf0b257c4545a0658a910475510a", "warmup_time": -1}, "passes.PassBenchmarks.time_size_pass": {"code": "class PassBenchmarks:\n    def time_size_pass(self, _, __):\n        Size().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_size_pass", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "aa12d81edb787335b5a9aff6e1f4491ce1f5f53bc5dfb4007f532c5a968c20aa", "warmup_time": -1}, "passes.PassBenchmarks.time_unroll_3q_or_more": {"code": "class PassBenchmarks:\n    def time_unroll_3q_or_more(self, _, __):\n        Unroll3qOrMore().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_unroll_3q_or_more", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "225008dfd0cf2cac8ccc91627836bb8d333cc7c51d3b3127400b3464dce09031", "warmup_time": -1}, "passes.PassBenchmarks.time_unroller": {"code": "class PassBenchmarks:\n    def time_unroller(self, _, __):\n        Unroller(self.basis_gates).run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_unroller", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "7d7303da52b85234a656ceaca8eb69301c8dab20d2aa312fa30d6885f4f84c7d", "warmup_time": -1}, "passes.PassBenchmarks.time_width_pass": {"code": "class PassBenchmarks:\n    def time_width_pass(self, _, __):\n        Width().run(self.dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "min_run_count": 2, "name": "passes.PassBenchmarks.time_width_pass", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "a24767d5b570b890ea88e5b2859b34a5a02975092eadb65d37d3bb2eca29644a", "warmup_time": -1}, "passes.PassBenchmarks.track_barrier_before_final_measurement": {"code": "class PassBenchmarks:\n    def track_barrier_before_final_measurement(self, _, __):\n        BarrierBeforeFinalMeasurements().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_barrier_before_final_measurement", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "2c00d8a4e636d4f3d70d7455dc5592f16a4a6bbe425ae571569c4bd35687c36e"}, "passes.PassBenchmarks.track_decompose_depth": {"code": "class PassBenchmarks:\n    def track_decompose_depth(self, _, __):\n        return Decompose().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_decompose_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "a0bb37e08cf0842c8a8233556852ed8e2a694764de8e57a6c035c1e9f582c813"}, "passes.PassBenchmarks.track_optimize_swap_before_measure_depth": {"code": "class PassBenchmarks:\n    def track_optimize_swap_before_measure_depth(self, _, __):\n        return OptimizeSwapBeforeMeasure().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_optimize_swap_before_measure_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "735ab624eb7363fd7ae46a3b5355d2c56d8d1167c147b6b9743dd57adcf421c4"}, "passes.PassBenchmarks.track_remove_diagonal_gates_before_measurement": {"code": "class PassBenchmarks:\n    def track_remove_diagonal_gates_before_measurement(self, _, __):\n        return RemoveDiagonalGatesBeforeMeasure().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_remove_diagonal_gates_before_measurement", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "8878ff2d64e45f8e9ea50c834b3e92e4f7ed3edc2775daa1a265c28e93194c26"}, "passes.PassBenchmarks.track_remove_final_measurements_depth": {"code": "class PassBenchmarks:\n    def track_remove_final_measurements_depth(self, _, __):\n        return RemoveFinalMeasurements().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_remove_final_measurements_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "8215ae5d023c93c7689b4f4664f3d158d46601fbc3473d340bbb48a5862f3475"}, "passes.PassBenchmarks.track_remove_reset_in_zero_state": {"code": "class PassBenchmarks:\n    def track_remove_reset_in_zero_state(self, _, __):\n        return RemoveResetInZeroState().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_remove_reset_in_zero_state", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "b264b9f6799c43007713810ad29eb6caa90c33b1c58fd5302a385d4c24ce3057"}, "passes.PassBenchmarks.track_unroll_3q_or_more_depth": {"code": "class PassBenchmarks:\n    def track_unroll_3q_or_more_depth(self, _, __):\n        return Unroll3qOrMore().run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_unroll_3q_or_more_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "ba2334c522f517ad0b2b9dbe24206a734597a392825aab01898b3fcb3cfd6d85"}, "passes.PassBenchmarks.track_unroller_depth": {"code": "class PassBenchmarks:\n    def track_unroller_depth(self, _, __):\n        return Unroller(self.basis_gates).run(self.dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']", "name": "passes.PassBenchmarks.track_unroller_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "52463c743ca3a26d3fee0e78c2bb48e9405a6cdc4dce4c1c638cbfa10b28007b"}, "passes.UnrolledPassBenchmarks.peakmem_optimize_1q": {"code": "class UnrolledPassBenchmarks:\n    def peakmem_optimize_1q(self, _, __):\n        Optimize1qGates().run(self.unrolled_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.unrolled_dag = Unroller(self.basis_gates).run(self.dag)", "name": "passes.UnrolledPassBenchmarks.peakmem_optimize_1q", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "peakmemory", "unit": "bytes", "version": "934a26dbac00d885afd2d6311c1a76f88183505f869eb1e78ace94411d5cc63e"}, "passes.UnrolledPassBenchmarks.time_optimize_1q": {"code": "class UnrolledPassBenchmarks:\n    def time_optimize_1q(self, _, __):\n        Optimize1qGates().run(self.unrolled_dag)\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.unrolled_dag = Unroller(self.basis_gates).run(self.dag)", "min_run_count": 2, "name": "passes.UnrolledPassBenchmarks.time_optimize_1q", "number": 0, "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 300, "type": "time", "unit": "seconds", "version": "51ea8a19f6134b2570746151ff0833bec8278aa108a13642c8ed25d7680ae7ae", "warmup_time": -1}, "passes.UnrolledPassBenchmarks.track_optimize_1q_depth": {"code": "class UnrolledPassBenchmarks:\n    def track_optimize_1q_depth(self, _, __):\n        return Optimize1qGates().run(self.unrolled_dag).depth()\n\n    def setup(self, n_qubits, depth):\n        seed = 42\n        self.circuit = random_circuit(n_qubits, depth, measure=True,\n                                      conditional=True, reset=True, seed=seed)\n        self.dag = circuit_to_dag(self.circuit)\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.unrolled_dag = Unroller(self.basis_gates).run(self.dag)", "name": "passes.UnrolledPassBenchmarks.track_optimize_1q_depth", "param_names": ["n_qubits", "depth"], "params": [["5", "14", "20"], ["1024"]], "timeout": 300, "type": "track", "unit": "unit", "version": "c05c9adac265420025b57cc1fdb6a167a919301ecaae9d4e893b17d5003bad34"}, "qft.QftTranspileBench.time_ibmq_backend_transpile": {"code": "class QftTranspileBench:\n    def time_ibmq_backend_transpile(self, _):\n        # Run with ibmq_16_melbourne configuration\n        coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                        [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                        [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],\n                        [13, 12]]\n        transpile(self.circuit,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  coupling_map=coupling_map)\n\n    def setup(self, n):\n        qr = QuantumRegister(n)\n        self.circuit = build_model_circuit(qr)\n        self.sim_backend = BasicAer.get_backend('qasm_simulator')", "min_run_count": 2, "name": "qft.QftTranspileBench.time_ibmq_backend_transpile", "number": 0, "param_names": ["param1"], "params": [["1", "2", "3", "5", "8", "13", "14"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "9893f71b35b93d314d19898b6d58e7b737e6bc51a86bbe74837b5fbdc1b13129", "warmup_time": -1}, "qft.QftTranspileBench.time_simulator_transpile": {"code": "class QftTranspileBench:\n    def time_simulator_transpile(self, _):\n        transpile(self.circuit, self.sim_backend)\n\n    def setup(self, n):\n        qr = QuantumRegister(n)\n        self.circuit = build_model_circuit(qr)\n        self.sim_backend = BasicAer.get_backend('qasm_simulator')", "min_run_count": 2, "name": "qft.QftTranspileBench.time_simulator_transpile", "number": 0, "param_names": ["param1"], "params": [["1", "2", "3", "5", "8", "13", "14"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "e855bf787ac8c340139762764dc55da27e0ab375bbf8b3c4180b131718bffecc", "warmup_time": -1}, "quantum_volume.QuantumVolumeBenchmark.time_ibmq_backend_transpile": {"code": "class QuantumVolumeBenchmark:\n    def time_ibmq_backend_transpile(self, _, __):\n        # Run with ibmq_16_melbourne configuration\n        coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                        [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                        [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],\n                        [13, 12]]\n    \n        transpile(self.circuit,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  coupling_map=coupling_map)\n\n    def setup(self, width, depth):\n        random_seed = np.random.seed(10)\n        if NO_KAK:\n            self.circuit = build_qv_model_circuit(\n                width=width, depth=depth, seed=random_seed)\n        else:\n            self.circuit = build_model_circuit_kak(width, depth, random_seed)\n    \n        self.sim_backend = QasmSimulatorPy()", "min_run_count": 2, "name": "quantum_volume.QuantumVolumeBenchmark.time_ibmq_backend_transpile", "number": 0, "param_names": ["width", "depth"], "params": [["1", "2", "3", "5", "8", "13", "14"], ["1", "2", "3", "5", "8", "13", "21", "34"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "2", "warmup_time": -1}, "quantum_volume.QuantumVolumeBenchmark.time_simulator_transpile": {"code": "class QuantumVolumeBenchmark:\n    def time_simulator_transpile(self, _, __):\n        transpile(self.circuit, self.sim_backend)\n\n    def setup(self, width, depth):\n        random_seed = np.random.seed(10)\n        if NO_KAK:\n            self.circuit = build_qv_model_circuit(\n                width=width, depth=depth, seed=random_seed)\n        else:\n            self.circuit = build_model_circuit_kak(width, depth, random_seed)\n    \n        self.sim_backend = QasmSimulatorPy()", "min_run_count": 2, "name": "quantum_volume.QuantumVolumeBenchmark.time_simulator_transpile", "number": 0, "param_names": ["width", "depth"], "params": [["1", "2", "3", "5", "8", "13", "14"], ["1", "2", "3", "5", "8", "13", "21", "34"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "2", "warmup_time": -1}, "random_circuit_hex.BenchRandomCircuitHex.time_ibmq_backend_transpile": {"code": "class BenchRandomCircuitHex:\n    def time_ibmq_backend_transpile(self, _):\n        # Run with ibmq_16_melbourne configuration\n        coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                        [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                        [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],\n                        [13, 12]]\n        transpile(self.circuit,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  coupling_map=coupling_map,\n                  **{TRANSPILER_SEED_KEYWORD: self.seed})\n\n    def setup(self, n):\n        depth = 2 * n\n        self.seed = 0\n        self.circuit = make_circuit_ring(n, depth, self.seed)[0]\n        self.sim_backend = BasicAer.get_backend('qasm_simulator')", "min_run_count": 2, "name": "random_circuit_hex.BenchRandomCircuitHex.time_ibmq_backend_transpile", "number": 0, "param_names": ["n_qubits"], "params": [["4", "6", "8", "10", "12", "14"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3", "warmup_time": -1}, "random_circuit_hex.BenchRandomCircuitHex.time_simulator_transpile": {"code": "class BenchRandomCircuitHex:\n    def time_simulator_transpile(self, _):\n        transpile(self.circuit, self.sim_backend,\n                  **{TRANSPILER_SEED_KEYWORD: self.seed})\n\n    def setup(self, n):\n        depth = 2 * n\n        self.seed = 0\n        self.circuit = make_circuit_ring(n, depth, self.seed)[0]\n        self.sim_backend = BasicAer.get_backend('qasm_simulator')", "min_run_count": 2, "name": "random_circuit_hex.BenchRandomCircuitHex.time_simulator_transpile", "number": 0, "param_names": ["n_qubits"], "params": [["4", "6", "8", "10", "12", "14"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "3", "warmup_time": -1}, "random_circuit_hex.BenchRandomCircuitHex.track_depth_ibmq_backend_transpile": {"code": "class BenchRandomCircuitHex:\n    def track_depth_ibmq_backend_transpile(self, _):\n        # Run with ibmq_16_melbourne configuration\n        coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                        [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                        [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],\n                        [13, 12]]\n        return transpile(self.circuit,\n                         basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                         coupling_map=coupling_map,\n                         **{TRANSPILER_SEED_KEYWORD: self.seed}).depth()\n\n    def setup(self, n):\n        depth = 2 * n\n        self.seed = 0\n        self.circuit = make_circuit_ring(n, depth, self.seed)[0]\n        self.sim_backend = BasicAer.get_backend('qasm_simulator')", "name": "random_circuit_hex.BenchRandomCircuitHex.track_depth_ibmq_backend_transpile", "param_names": ["n_qubits"], "params": [["4", "6", "8", "10", "12", "14"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "3"}, "random_circuit_hex.BenchRandomCircuitHex.track_depth_simulator_transpile": {"code": "class BenchRandomCircuitHex:\n    def track_depth_simulator_transpile(self, _):\n        return transpile(self.circuit, self.sim_backend,\n                         **{TRANSPILER_SEED_KEYWORD: self.seed}).depth()\n\n    def setup(self, n):\n        depth = 2 * n\n        self.seed = 0\n        self.circuit = make_circuit_ring(n, depth, self.seed)[0]\n        self.sim_backend = BasicAer.get_backend('qasm_simulator')", "name": "random_circuit_hex.BenchRandomCircuitHex.track_depth_simulator_transpile", "param_names": ["n_qubits"], "params": [["4", "6", "8", "10", "12", "14"]], "timeout": 60.0, "type": "track", "unit": "unit", "version": "3"}, "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_ibmq_backend_transpile": {"code": "class RandomizedBenchmarkingBenchmark:\n    def time_ibmq_backend_transpile(self, __):\n        # Run with ibmq_16_melbourne configuration\n        coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                        [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                        [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],\n                        [13, 12]]\n    \n        transpile(self.circuits,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  coupling_map=coupling_map,\n                  **{TRANSPILER_SEED_KEYWORD: self.seed})\n\n    def setup(self, rb_pattern):\n        length_vector = np.arange(1, 200, 4)\n        nseeds = 1\n        self.seed = 10\n        self.circuits = build_rb_circuit(nseeds=nseeds,\n                                         length_vector=length_vector,\n                                         rb_pattern=rb_pattern,\n                                         seed=self.seed)\n        self.sim_backend = QasmSimulatorPy()", "min_run_count": 2, "name": "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_ibmq_backend_transpile", "number": 0, "param_names": ["rb_pattern"], "params": [["[[0]]", "[[0, 1]]", "[[0, 2], [1]]"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "0.2.0", "warmup_time": -1}, "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_ibmq_backend_transpile_single_thread": {"code": "class RandomizedBenchmarkingBenchmark:\n    def time_ibmq_backend_transpile_single_thread(self, __):\n        os.environ['QISKIT_IN_PARALLEL'] = 'TRUE'\n    \n        # Run with ibmq_16_melbourne configuration\n        coupling_map = [[1, 0], [1, 2], [2, 3], [4, 3], [4, 10], [5, 4],\n                        [5, 6], [5, 9], [6, 8], [7, 8], [9, 8], [9, 10],\n                        [11, 3], [11, 10], [11, 12], [12, 2], [13, 1],\n                        [13, 12]]\n    \n        transpile(self.circuits,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  coupling_map=coupling_map,\n                  **{TRANSPILER_SEED_KEYWORD: self.seed})\n\n    def setup(self, rb_pattern):\n        length_vector = np.arange(1, 200, 4)\n        nseeds = 1\n        self.seed = 10\n        self.circuits = build_rb_circuit(nseeds=nseeds,\n                                         length_vector=length_vector,\n                                         rb_pattern=rb_pattern,\n                                         seed=self.seed)\n        self.sim_backend = QasmSimulatorPy()", "min_run_count": 2, "name": "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_ibmq_backend_transpile_single_thread", "number": 0, "param_names": ["rb_pattern"], "params": [["[[0]]", "[[0, 1]]", "[[0, 2], [1]]"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "0.2.0", "warmup_time": -1}, "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_simulator_transpile": {"code": "class RandomizedBenchmarkingBenchmark:\n    def time_simulator_transpile(self, __):\n        transpile(self.circuits, self.sim_backend,\n                  **{TRANSPILER_SEED_KEYWORD: self.seed})\n\n    def setup(self, rb_pattern):\n        length_vector = np.arange(1, 200, 4)\n        nseeds = 1\n        self.seed = 10\n        self.circuits = build_rb_circuit(nseeds=nseeds,\n                                         length_vector=length_vector,\n                                         rb_pattern=rb_pattern,\n                                         seed=self.seed)\n        self.sim_backend = QasmSimulatorPy()", "min_run_count": 2, "name": "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_simulator_transpile", "number": 0, "param_names": ["rb_pattern"], "params": [["[[0]]", "[[0, 1]]", "[[0, 2], [1]]"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "0.2.0", "warmup_time": -1}, "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_simulator_transpile_single_thread": {"code": "class RandomizedBenchmarkingBenchmark:\n    def time_simulator_transpile_single_thread(self, __):\n        os.environ['QISKIT_IN_PARALLEL'] = 'TRUE'\n        transpile(self.circuits, self.sim_backend,\n                  **{TRANSPILER_SEED_KEYWORD: self.seed})\n\n    def setup(self, rb_pattern):\n        length_vector = np.arange(1, 200, 4)\n        nseeds = 1\n        self.seed = 10\n        self.circuits = build_rb_circuit(nseeds=nseeds,\n                                         length_vector=length_vector,\n                                         rb_pattern=rb_pattern,\n                                         seed=self.seed)\n        self.sim_backend = QasmSimulatorPy()", "min_run_count": 2, "name": "randomized_benchmarking.RandomizedBenchmarkingBenchmark.time_simulator_transpile_single_thread", "number": 0, "param_names": ["rb_pattern"], "params": [["[[0]]", "[[0, 1]]", "[[0, 2], [1]]"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "0.2.0", "warmup_time": -1}, "ripple_adder.RippleAdderConstruction.peakmem_build_ripple_adder": {"code": "class RippleAdderConstruction:\n    def peakmem_build_ripple_adder(self, size):\n        build_ripple_adder_circuit(size)", "name": "ripple_adder.RippleAdderConstruction.peakmem_build_ripple_adder", "param_names": ["size"], "params": [["10", "50", "100", "200", "500"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "1"}, "ripple_adder.RippleAdderConstruction.time_build_ripple_adder": {"code": "class RippleAdderConstruction:\n    def time_build_ripple_adder(self, size):\n        build_ripple_adder_circuit(size)", "min_run_count": 2, "name": "ripple_adder.RippleAdderConstruction.time_build_ripple_adder", "number": 0, "param_names": ["size"], "params": [["10", "50", "100", "200", "500"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "1", "warmup_time": -1}, "ripple_adder.RippleAdderTranspile.peakmem_transpile_simulator_ripple_adder": {"code": "class RippleAdderTranspile:\n    def peakmem_transpile_simulator_ripple_adder(self, _, level):\n        transpile(self.circuit, self.sim_backend,\n                  optimization_level=level)\n\n    def setup(self, size, _):\n        edge_len = int((2*size + 2)**0.5)+1\n        self.coupling_map = CouplingMap.from_grid(edge_len, edge_len)\n        self.sim_backend = QasmSimulatorPy()\n        self.circuit = build_ripple_adder_circuit(size)", "name": "ripple_adder.RippleAdderTranspile.peakmem_transpile_simulator_ripple_adder", "param_names": ["size", "level"], "params": [["10", "20"], ["0", "1", "2", "3"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "1"}, "ripple_adder.RippleAdderTranspile.peakmem_transpile_square_grid_ripple_adder": {"code": "class RippleAdderTranspile:\n    def peakmem_transpile_square_grid_ripple_adder(self, _, level):\n        transpile(self.circuit,\n                  coupling_map=self.coupling_map,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  optimization_level=level)\n\n    def setup(self, size, _):\n        edge_len = int((2*size + 2)**0.5)+1\n        self.coupling_map = CouplingMap.from_grid(edge_len, edge_len)\n        self.sim_backend = QasmSimulatorPy()\n        self.circuit = build_ripple_adder_circuit(size)", "name": "ripple_adder.RippleAdderTranspile.peakmem_transpile_square_grid_ripple_adder", "param_names": ["size", "level"], "params": [["10", "20"], ["0", "1", "2", "3"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "1"}, "ripple_adder.RippleAdderTranspile.time_transpile_simulator_ripple_adder": {"code": "class RippleAdderTranspile:\n    def time_transpile_simulator_ripple_adder(self, _, level):\n        transpile(self.circuit, self.sim_backend,\n                  optimization_level=level)\n\n    def setup(self, size, _):\n        edge_len = int((2*size + 2)**0.5)+1\n        self.coupling_map = CouplingMap.from_grid(edge_len, edge_len)\n        self.sim_backend = QasmSimulatorPy()\n        self.circuit = build_ripple_adder_circuit(size)", "min_run_count": 2, "name": "ripple_adder.RippleAdderTranspile.time_transpile_simulator_ripple_adder", "number": 0, "param_names": ["size", "level"], "params": [["10", "20"], ["0", "1", "2", "3"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "1", "warmup_time": -1}, "ripple_adder.RippleAdderTranspile.time_transpile_square_grid_ripple_adder": {"code": "class RippleAdderTranspile:\n    def time_transpile_square_grid_ripple_adder(self, _, level):\n        transpile(self.circuit,\n                  coupling_map=self.coupling_map,\n                  basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                  optimization_level=level)\n\n    def setup(self, size, _):\n        edge_len = int((2*size + 2)**0.5)+1\n        self.coupling_map = CouplingMap.from_grid(edge_len, edge_len)\n        self.sim_backend = QasmSimulatorPy()\n        self.circuit = build_ripple_adder_circuit(size)", "min_run_count": 2, "name": "ripple_adder.RippleAdderTranspile.time_transpile_square_grid_ripple_adder", "number": 0, "param_names": ["size", "level"], "params": [["10", "20"], ["0", "1", "2", "3"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "1", "warmup_time": -1}, "ripple_adder.RippleAdderTranspile.track_depth_transpile_simulator_ripple_adder": {"code": "class RippleAdderTranspile:\n    def track_depth_transpile_simulator_ripple_adder(self, _, level):\n        return transpile(self.circuit, self.sim_backend,\n                         optimization_level=level).depth()\n\n    def setup(self, size, _):\n        edge_len = int((2*size + 2)**0.5)+1\n        self.coupling_map = CouplingMap.from_grid(edge_len, edge_len)\n        self.sim_backend = QasmSimulatorPy()\n        self.circuit = build_ripple_adder_circuit(size)", "name": "ripple_adder.RippleAdderTranspile.track_depth_transpile_simulator_ripple_adder", "param_names": ["size", "level"], "params": [["10", "20"], ["0", "1", "2", "3"]], "timeout": 600, "type": "track", "unit": "unit", "version": "1"}, "ripple_adder.RippleAdderTranspile.track_depth_transpile_square_grid_ripple_adder": {"code": "class RippleAdderTranspile:\n    def track_depth_transpile_square_grid_ripple_adder(self, _, level):\n        return transpile(self.circuit,\n                         coupling_map=self.coupling_map,\n                         basis_gates=['u1', 'u2', 'u3', 'cx', 'id'],\n                         optimization_level=level).depth()\n\n    def setup(self, size, _):\n        edge_len = int((2*size + 2)**0.5)+1\n        self.coupling_map = CouplingMap.from_grid(edge_len, edge_len)\n        self.sim_backend = QasmSimulatorPy()\n        self.circuit = build_ripple_adder_circuit(size)", "name": "ripple_adder.RippleAdderTranspile.track_depth_transpile_square_grid_ripple_adder", "param_names": ["size", "level"], "params": [["10", "20"], ["0", "1", "2", "3"]], "timeout": 600, "type": "track", "unit": "unit", "version": "1"}, "state_tomography.StateTomographyBench.time_state_tomography_bell": {"code": "class StateTomographyBench:\n    def time_state_tomography_bell(self, n_qubits):\n        qr = qiskit.QuantumRegister(2)\n        bell = qiskit.QuantumCircuit(qr)\n        bell.h(qr[0])\n        bell.cx(qr[0], qr[1])\n        psi_bell = qiskit.execute(\n            bell, self.sv_backend).result().get_statevector(bell)\n        qr_full = qiskit.QuantumRegister(n_qubits)\n        bell = qiskit.QuantumCircuit(qr_full)\n        bell.h(qr_full[n_qubits - 2])\n        bell.cx(qr_full[n_qubits - 2], qr_full[n_qubits - 1])\n        qst_bell = tomo.state_tomography_circuits(bell,\n                                                  [qr_full[n_qubits - 2],\n                                                   qr_full[n_qubits - 1]])\n        job = qiskit.execute(qst_bell, self.qasm_backend, shots=5000)\n        rho_bell = tomo.StateTomographyFitter(job.result(), qst_bell).fit()\n        state_fidelity(psi_bell, rho_bell)\n\n    def setup(self, _):\n        self.sv_backend = qiskit.BasicAer.get_backend('statevector_simulator')\n        self.qasm_backend = qiskit.BasicAer.get_backend('qasm_simulator')", "min_run_count": 2, "name": "state_tomography.StateTomographyBench.time_state_tomography_bell", "number": 0, "param_names": ["n_qubits"], "params": [["2", "3", "4", "5"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 120.0, "type": "time", "unit": "seconds", "version": "0.2.0", "warmup_time": -1}, "state_tomography.StateTomographyBench.time_state_tomography_cat": {"code": "class StateTomographyBench:\n    def time_state_tomography_cat(self, n_qubits):\n        qr = qiskit.QuantumRegister(n_qubits, 'qr')\n        circ = qiskit.QuantumCircuit(qr, name='cat')\n        circ.h(qr[0])\n        for i in range(1, n_qubits):\n            circ.cx(qr[0], qr[i])\n        psi = qiskit.execute(circ, self.sv_backend).result().get_statevector()\n        qst_circ = tomo.state_tomography_circuits(circ, qr)\n        tomo_result = qiskit.execute(\n            qst_circ, self.qasm_backend, shots=5000).result()\n        rho = tomo.StateTomographyFitter(tomo_result, qst_circ).fit()\n        state_fidelity(psi, rho)\n\n    def setup(self, _):\n        self.sv_backend = qiskit.BasicAer.get_backend('statevector_simulator')\n        self.qasm_backend = qiskit.BasicAer.get_backend('qasm_simulator')", "min_run_count": 2, "name": "state_tomography.StateTomographyBench.time_state_tomography_cat", "number": 0, "param_names": ["n_qubits"], "params": [["2", "3", "4", "5"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 120.0, "type": "time", "unit": "seconds", "version": "0.2.0", "warmup_time": -1}, "transpiler_benchmarks.TranspilerBenchSuite.time_cx_transpile": {"code": "class TranspilerBenchSuite:\n    def time_cx_transpile(self):\n        if self.local_qasm_simulator is None:\n            self.cx_circuit.compile('cx_circuit')\n        else:\n            if self.has_compile:\n                qiskit.compile(self.cx_circuit, self.local_qasm_simulator)\n            else:\n                circ = qiskit.compiler.transpile(self.cx_circuit,\n                                                 self.local_qasm_simulator)\n                qiskit.compiler.assemble(circ, self.local_qasm_simulator)\n\n    def setup(self):\n        version_parts = qiskit.__version__.split('.')\n    \n        if version_parts[0] == '0' and int(version_parts[1]) < 5:\n            self.local_qasm_simulator = None\n        elif hasattr(qiskit, 'BasicAer'):\n            self.local_qasm_simulator = qiskit.BasicAer.get_backend(\n                'qasm_simulator')\n        elif hasattr(qiskit, 'get_backend'):\n            self.local_qasm_simulator = qiskit.get_backend(\n                'local_qasm_simulator')\n        else:\n            self.local_qasm_simulator = qiskit.BasicAer.get_backend(\n                \"qasm_simulator\")\n        self.has_compile = False\n        if hasattr(qiskit, 'compile'):\n            self.has_compile = True\n        self.single_gate_circuit = self._build_single_gate_circuit()\n        self.cx_circuit = self._build_cx_circuit()\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n    \n        if hasattr(qiskit, 'load_qasm_file'):\n            self.large_qasm = qiskit.load_qasm_file(large_qasm_path)\n        elif version_parts[0] == '0' and int(version_parts[1]) < 5:\n            self.large_qasm = qiskit.QuantumProgram()\n            self.large_qasm.load_qasm_file(large_qasm_path,\n                                           name='large_qasm')\n        else:\n            self.large_qasm = qiskit.QuantumCircuit.from_qasm_file(\n                large_qasm_path)", "min_run_count": 2, "name": "transpiler_benchmarks.TranspilerBenchSuite.time_cx_transpile", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "1beb15c5e1298c97cc80a920d3bc6ae17ae2e3d1b96634473c1ca0d662515239", "warmup_time": -1}, "transpiler_benchmarks.TranspilerBenchSuite.time_single_gate_transpile": {"code": "class TranspilerBenchSuite:\n    def time_single_gate_transpile(self):\n        if self.local_qasm_simulator is None:\n            self.single_gate_circuit.compile('single_gate')\n        else:\n            if self.has_compile:\n                qiskit.compile(self.single_gate_circuit,\n                               self.local_qasm_simulator)\n            else:\n                circ = qiskit.compiler.transpile(self.single_gate_circuit,\n                                                 self.local_qasm_simulator)\n                qiskit.compiler.assemble(circ, self.local_qasm_simulator)\n\n    def setup(self):\n        version_parts = qiskit.__version__.split('.')\n    \n        if version_parts[0] == '0' and int(version_parts[1]) < 5:\n            self.local_qasm_simulator = None\n        elif hasattr(qiskit, 'BasicAer'):\n            self.local_qasm_simulator = qiskit.BasicAer.get_backend(\n                'qasm_simulator')\n        elif hasattr(qiskit, 'get_backend'):\n            self.local_qasm_simulator = qiskit.get_backend(\n                'local_qasm_simulator')\n        else:\n            self.local_qasm_simulator = qiskit.BasicAer.get_backend(\n                \"qasm_simulator\")\n        self.has_compile = False\n        if hasattr(qiskit, 'compile'):\n            self.has_compile = True\n        self.single_gate_circuit = self._build_single_gate_circuit()\n        self.cx_circuit = self._build_cx_circuit()\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n    \n        if hasattr(qiskit, 'load_qasm_file'):\n            self.large_qasm = qiskit.load_qasm_file(large_qasm_path)\n        elif version_parts[0] == '0' and int(version_parts[1]) < 5:\n            self.large_qasm = qiskit.QuantumProgram()\n            self.large_qasm.load_qasm_file(large_qasm_path,\n                                           name='large_qasm')\n        else:\n            self.large_qasm = qiskit.QuantumCircuit.from_qasm_file(\n                large_qasm_path)", "min_run_count": 2, "name": "transpiler_benchmarks.TranspilerBenchSuite.time_single_gate_transpile", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "ae2aeb23bc5b306911398e0bf7c9ad54be52c6ef8a6bb1d3e263c15de3c374bd", "warmup_time": -1}, "transpiler_benchmarks.TranspilerBenchSuite.time_transpile_from_large_qasm": {"code": "class TranspilerBenchSuite:\n    def time_transpile_from_large_qasm(self):\n        if self.local_qasm_simulator is None:\n            self.large_qasm.compile('large_qasm')\n        else:\n            if self.has_compile:\n                qiskit.compile(self.large_qasm, self.local_qasm_simulator)\n            else:\n                circ = qiskit.compiler.transpile(self.large_qasm,\n                                                 self.local_qasm_simulator)\n                qiskit.compiler.assemble(circ, self.local_qasm_simulator)\n\n    def setup(self):\n        version_parts = qiskit.__version__.split('.')\n    \n        if version_parts[0] == '0' and int(version_parts[1]) < 5:\n            self.local_qasm_simulator = None\n        elif hasattr(qiskit, 'BasicAer'):\n            self.local_qasm_simulator = qiskit.BasicAer.get_backend(\n                'qasm_simulator')\n        elif hasattr(qiskit, 'get_backend'):\n            self.local_qasm_simulator = qiskit.get_backend(\n                'local_qasm_simulator')\n        else:\n            self.local_qasm_simulator = qiskit.BasicAer.get_backend(\n                \"qasm_simulator\")\n        self.has_compile = False\n        if hasattr(qiskit, 'compile'):\n            self.has_compile = True\n        self.single_gate_circuit = self._build_single_gate_circuit()\n        self.cx_circuit = self._build_cx_circuit()\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n    \n        if hasattr(qiskit, 'load_qasm_file'):\n            self.large_qasm = qiskit.load_qasm_file(large_qasm_path)\n        elif version_parts[0] == '0' and int(version_parts[1]) < 5:\n            self.large_qasm = qiskit.QuantumProgram()\n            self.large_qasm.load_qasm_file(large_qasm_path,\n                                           name='large_qasm')\n        else:\n            self.large_qasm = qiskit.QuantumCircuit.from_qasm_file(\n                large_qasm_path)", "min_run_count": 2, "name": "transpiler_benchmarks.TranspilerBenchSuite.time_transpile_from_large_qasm", "number": 0, "param_names": [], "params": [], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 60.0, "type": "time", "unit": "seconds", "version": "db325d2ed02ae2d040b6100833be8c2be79b1d7317f457f35fe1b36e405d5b9d", "warmup_time": -1}, "transpiler_levels.TranspilerLevelBenchmarks.peakmem_quantum_volume_transpile_50_x_20": {"code": "class TranspilerLevelBenchmarks:\n    def peakmem_quantum_volume_transpile_50_x_20(self, transpiler_level):\n        transpile(self.qv_50_x_20, basis_gates=self.basis_gates,\n                  coupling_map=self.rochester_coupling_map,\n                  seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.peakmem_quantum_volume_transpile_50_x_20", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "aba66246c59afbeabd0259166d863a0fb8c8e8db5413bcc3001529aa0a911b8f"}, "transpiler_levels.TranspilerLevelBenchmarks.peakmem_transpile_from_large_qasm": {"code": "class TranspilerLevelBenchmarks:\n    def peakmem_transpile_from_large_qasm(self, transpiler_level):\n        transpile(self.large_qasm, basis_gates=self.basis_gates,\n                  coupling_map=self.rochester_coupling_map,\n                  seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.peakmem_transpile_from_large_qasm", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "f77217086bf925f18b753d2efaca34566a1c58dde99f7070aa48559befc04029"}, "transpiler_levels.TranspilerLevelBenchmarks.peakmem_transpile_from_large_qasm_backend_with_prop": {"code": "class TranspilerLevelBenchmarks:\n    def peakmem_transpile_from_large_qasm_backend_with_prop(self,\n                                                            transpiler_level):\n        transpile(self.large_qasm, self.melbourne, seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.peakmem_transpile_from_large_qasm_backend_with_prop", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "2ddf943466b7d9be234a957397bbbaaf7b3a3e50976eb5793914583405e7c4ce"}, "transpiler_levels.TranspilerLevelBenchmarks.peakmem_transpile_qv_14_x_14": {"code": "class TranspilerLevelBenchmarks:\n    def peakmem_transpile_qv_14_x_14(self, transpiler_level):\n        transpile(self.qv_14_x_14, self.melbourne, seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.peakmem_transpile_qv_14_x_14", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "peakmemory", "unit": "bytes", "version": "9f61925e64843ecde503f086c0beea456eb498fcbd3f17a4b4cd7f64a30415fe"}, "transpiler_levels.TranspilerLevelBenchmarks.time_quantum_volume_transpile_50_x_20": {"code": "class TranspilerLevelBenchmarks:\n    def time_quantum_volume_transpile_50_x_20(self, transpiler_level):\n        transpile(self.qv_50_x_20, basis_gates=self.basis_gates,\n                  coupling_map=self.rochester_coupling_map,\n                  seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "min_run_count": 2, "name": "transpiler_levels.TranspilerLevelBenchmarks.time_quantum_volume_transpile_50_x_20", "number": 0, "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "fab844d8c9f845a09362293abc934b1c39c0bd1db16710a456fe46fe86ee5570", "warmup_time": -1}, "transpiler_levels.TranspilerLevelBenchmarks.time_transpile_from_large_qasm": {"code": "class TranspilerLevelBenchmarks:\n    def time_transpile_from_large_qasm(self, transpiler_level):\n        transpile(self.large_qasm, basis_gates=self.basis_gates,\n                  coupling_map=self.rochester_coupling_map,\n                  seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "min_run_count": 2, "name": "transpiler_levels.TranspilerLevelBenchmarks.time_transpile_from_large_qasm", "number": 0, "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "c072fc082a32e8870d0e7258f56083f4f58210a84372f7a5fef98db473cd9a56", "warmup_time": -1}, "transpiler_levels.TranspilerLevelBenchmarks.time_transpile_from_large_qasm_backend_with_prop": {"code": "class TranspilerLevelBenchmarks:\n    def time_transpile_from_large_qasm_backend_with_prop(self,\n                                                         transpiler_level):\n        transpile(self.large_qasm, self.melbourne, seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "min_run_count": 2, "name": "transpiler_levels.TranspilerLevelBenchmarks.time_transpile_from_large_qasm_backend_with_prop", "number": 0, "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "d62d3c2a6414fada2f20c68b3de89d7323e7d712f18fd3663d97ada076b4f5e1", "warmup_time": -1}, "transpiler_levels.TranspilerLevelBenchmarks.time_transpile_qv_14_x_14": {"code": "class TranspilerLevelBenchmarks:\n    def time_transpile_qv_14_x_14(self, transpiler_level):\n        transpile(self.qv_14_x_14, self.melbourne, seed_transpiler=0,\n                  optimization_level=transpiler_level)\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "min_run_count": 2, "name": "transpiler_levels.TranspilerLevelBenchmarks.time_transpile_qv_14_x_14", "number": 0, "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "processes": 2, "repeat": 0, "sample_time": 0.01, "timeout": 600, "type": "time", "unit": "seconds", "version": "bc4f75183dd56fab4a09b01c57b13d28d97979baad4907871aabe655c3310f48", "warmup_time": -1}, "transpiler_levels.TranspilerLevelBenchmarks.track_depth_quantum_volume_transpile_50_x_20": {"code": "class TranspilerLevelBenchmarks:\n    def track_depth_quantum_volume_transpile_50_x_20(self, transpiler_level):\n        return transpile(self.qv_50_x_20, basis_gates=self.basis_gates,\n                         coupling_map=self.rochester_coupling_map,\n                         seed_transpiler=0,\n                         optimization_level=transpiler_level).depth()\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.track_depth_quantum_volume_transpile_50_x_20", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "track", "unit": "unit", "version": "47419947438fa26e9301695ddec438d1cc423156d6e7bd3f49f9f816207b81b8"}, "transpiler_levels.TranspilerLevelBenchmarks.track_depth_transpile_from_large_qasm": {"code": "class TranspilerLevelBenchmarks:\n    def track_depth_transpile_from_large_qasm(self, transpiler_level):\n        return transpile(self.large_qasm, basis_gates=self.basis_gates,\n                         coupling_map=self.rochester_coupling_map,\n                         seed_transpiler=0,\n                         optimization_level=transpiler_level).depth()\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.track_depth_transpile_from_large_qasm", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "track", "unit": "unit", "version": "7c5b2ce02c74f1c384a20120f5a09411416a467eb3cd35c0d1ab8ea227e94e20"}, "transpiler_levels.TranspilerLevelBenchmarks.track_depth_transpile_from_large_qasm_backend_with_prop": {"code": "class TranspilerLevelBenchmarks:\n    def track_depth_transpile_from_large_qasm_backend_with_prop(\n            self, transpiler_level):\n        return transpile(self.large_qasm, self.melbourne, seed_transpiler=0,\n                         optimization_level=transpiler_level).depth()\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.track_depth_transpile_from_large_qasm_backend_with_prop", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "track", "unit": "unit", "version": "9143d33380a73aaf79a97001f18b5ed894431811331ba5622d43121e1ce53d34"}, "transpiler_levels.TranspilerLevelBenchmarks.track_depth_transpile_qv_14_x_14": {"code": "class TranspilerLevelBenchmarks:\n    def track_depth_transpile_qv_14_x_14(self, transpiler_level):\n        return transpile(self.qv_14_x_14, self.melbourne, seed_transpiler=0,\n                         optimization_level=transpiler_level).depth()\n\n    def setup(self, _):\n        self.rochester_coupling_map = [\n            [0, 5],\n            [0, 1],\n            [1, 2],\n            [1, 0],\n            [2, 3],\n            [2, 1],\n            [3, 4],\n            [3, 2],\n            [4, 6],\n            [4, 3],\n            [5, 9],\n            [5, 0],\n            [6, 13],\n            [6, 4],\n            [7, 16],\n            [7, 8],\n            [8, 9],\n            [8, 7],\n            [9, 10],\n            [9, 8],\n            [9, 5],\n            [10, 11],\n            [10, 9],\n            [11, 17],\n            [11, 12],\n            [11, 10],\n            [12, 13],\n            [12, 11],\n            [13, 14],\n            [13, 12],\n            [13, 6],\n            [14, 15],\n            [14, 13],\n            [15, 18],\n            [15, 14],\n            [16, 19],\n            [16, 7],\n            [17, 23],\n            [17, 11],\n            [18, 27],\n            [18, 15],\n            [19, 20],\n            [19, 16],\n            [20, 21],\n            [20, 19],\n            [21, 28],\n            [21, 22],\n            [21, 20],\n            [22, 23],\n            [22, 21],\n            [23, 24],\n            [23, 22],\n            [23, 17],\n            [24, 25],\n            [24, 23],\n            [25, 29],\n            [25, 26],\n            [25, 24],\n            [26, 27],\n            [26, 25],\n            [27, 26],\n            [27, 18],\n            [28, 32],\n            [28, 21],\n            [29, 36],\n            [29, 25],\n            [30, 39],\n            [30, 31],\n            [31, 32],\n            [31, 30],\n            [32, 33],\n            [32, 31],\n            [32, 28],\n            [33, 34],\n            [33, 32],\n            [34, 40],\n            [34, 35],\n            [34, 33],\n            [35, 36],\n            [35, 34],\n            [36, 37],\n            [36, 35],\n            [36, 29],\n            [37, 38],\n            [37, 36],\n            [38, 41],\n            [38, 37],\n            [39, 42],\n            [39, 30],\n            [40, 46],\n            [40, 34],\n            [41, 50],\n            [41, 38],\n            [42, 43],\n            [42, 39],\n            [43, 44],\n            [43, 42],\n            [44, 51],\n            [44, 45],\n            [44, 43],\n            [45, 46],\n            [45, 44],\n            [46, 47],\n            [46, 45],\n            [46, 40],\n            [47, 48],\n            [47, 46],\n            [48, 52],\n            [48, 49],\n            [48, 47],\n            [49, 50],\n            [49, 48],\n            [50, 49],\n            [50, 41],\n            [51, 44],\n            [52, 48]]\n        self.basis_gates = ['u1', 'u2', 'u3', 'cx', 'id']\n        self.qv_50_x_20 = build_qv_model_circuit(50, 20, 0)\n        self.qv_14_x_14 = build_qv_model_circuit(14, 14, 0)\n        self.qasm_path = os.path.abspath(\n            os.path.join(os.path.dirname(__file__), 'qasm'))\n        large_qasm_path = os.path.join(self.qasm_path, 'test_eoh_qasm.qasm')\n        self.large_qasm = QuantumCircuit.from_qasm_file(large_qasm_path)\n        self.melbourne = FakeMelbourne()", "name": "transpiler_levels.TranspilerLevelBenchmarks.track_depth_transpile_qv_14_x_14", "param_names": ["transpiler optimization level"], "params": [["0", "1", "2", "3"]], "timeout": 600, "type": "track", "unit": "unit", "version": "b800c3105167c4d2ed5f9212b65b179a3c521803cb064051ff74509409d95e79"}}, "machines": {"qiskit-benchmarking": {"arch": "x86_64", "cpu": "Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz", "machine": "qiskit-benchmarking", "num_cpu": "4", "os": "Ubuntu 18.04", "ram": "16 GB", "version": 1}}, "tags": {"0.1": 17, "0.10.0": 16795, "0.11.0": 18605, "0.11.1": 19119, "0.12.0": 19887, "0.2": 451, "0.3": 867, "0.3.10": 1493, "0.3.11": 1548, "0.3.12": 1611, "0.3.13": 1703, "0.3.14": 1719, "0.3.15": 1790, "0.3.16": 1793, "0.3.3": 985, "0.3.4": 986, "0.3.5": 1023, "0.3.6": 1099, "0.3.7": 1383, "0.3.8": 1405, "0.3.9": 1434, "0.4.0": 1858, "0.4.10": 3058, "0.4.11": 3112, "0.4.12": 3383, "0.4.13": 3471, "0.4.14": 3514, "0.4.15": 3807, "0.4.2": 1860, "0.4.3": 1865, "0.4.4": 1870, "0.4.6": 1887, "0.4.7": 1892, "0.4.8": 1899, "0.4.9": 2936, "0.5.0": 3852, "0.5.1": 3875, "0.5.2": 3902, "0.5.3": 3947, "0.5.4": 4030, "0.5.5": 4278, "0.5.6": 4346, "0.5.7": 4400, "0.6.0": 5427, "0.6.1": 5454, "0.7.0": 7808, "0.7.1": 9293, "0.7.2": 11737, "0.8.0": 11904, "0.8.1": 12826, "0.8.2": 13364, "0.9.0": 15525, "0.9.1": 16679}, "pages": [["", "Grid view", "Display as a agrid"], ["summarylist", "List view", "Display as a list"], ["regressions", "Show regressions", "Display information about recent regressions"]]}